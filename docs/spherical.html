<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>stripy.spherical API documentation</title>
<meta name="description" content="Copyright 2017-2019 Louis Moresi, Ben Mather â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stripy.spherical</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2017-2019 Louis Moresi, Ben Mather</p>
<p>This file is part of Stripy.</p>
<p>Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Stripy.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2017-2019 Louis Moresi, Ben Mather

This file is part of Stripy.

Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Stripy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

#!/usr/bin/python
# -*- coding: utf-8 -*-
from multiprocessing import cpu_count

from . import _stripack
from . import _ssrfpack
import numpy as np

try: range = xrange
except: pass

_ier_codes = {0:  &#34;no errors were encountered.&#34;,
              -1: &#34;N &lt; 3 on input.&#34;,
              -2: &#34;the first three nodes lie on a great circle.\nSet permute to True or reorder nodes manually.&#34;,
              -3: &#34;duplicate nodes were encountered.&#34;,
              -4: &#34;an error flag was returned by a call to SWAP in ADDNOD.\n \
                   This is an internal error and should be reported to the programmer.&#34;,
              &#39;L&#39;:&#34;nodes L and M coincide for some M &gt; L.\n \
                   The linked list represents a triangulation of nodes 1 to M-1 in this case.&#34;,
              1: &#34;NCC, N, NROW, or an LCC entry is outside its valid range on input.&#34;,
              2: &#34;the triangulation data structure (LIST,LPTR,LEND) is invalid.&#34;,
              &#39;K&#39;: &#39;NPTS(K) is not a valid index in the range 1 to N.&#39;,
              9999: &#34;Triangulation encountered duplicate nodes.&#34;}


def _auto_threads(n_in, n_out, order):
    &#34;&#34;&#34;Attempt to automatically determine the best number of threads to use
    for spherical interpolation.

    Parameters
    ----------
    n_in : int
        Number of input points for triangulation.
    n_out : int
        Number of output points for interpolation.
    order : {0, 1, 3}
        Order of interpolation (nearest-neighbour, linear, cubic).

    Returns
    -------
    threads : int
        Number of threads to use.
    &#34;&#34;&#34;
    if order == 3:
        use_threads = False
    elif n_out &gt;= 50000:
        use_threads = True
    elif n_out &gt;= 5000 and n_in &gt;= 10000:
        use_threads = True
    else:
        use_threads = False
    return cpu_count() if use_threads else 1


class sTriangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given points on a sphere
    where lons and lats are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
        and Voronoi diagram on the surface of a sphere&#34;
        ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
        doi:10.1145/275323.275329

    Args:
        lons : 1D array
            longitudinal coordinates in radians
        lats : 1D array
            latitudinal coordinates in radians
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        lons : array of floats, shape (n,)
            stored longitudinal coordinates on a sphere
        lats : array of floats, shape (n,)
            stored latitudinal coordinates on a sphere
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        z : array of floats, shape (n,)
            stored Cartesian z coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity O(N*log(N)) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as O(N**2) if, for example, the nodes are ordered
        on increasing latitude.

        if permute=True, lons and lats are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting permute=True and permute=False,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, lons, lats, refinement_levels=0, permute=False, tree=False):

        # lons, lats = self._check_integrity(lons, lats)
        self.permute = permute
        self.tree = tree

        self._update_triangulation(lons, lats)

        for r in range(0,refinement_levels):
            lons, lats = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(lons,lats)

        return

    def _generate_permutation(self, npoints):
        &#34;&#34;&#34;
        Create shuffle and deshuffle vectors
        &#34;&#34;&#34;
        i = np.arange(0, npoints)
        # permutation
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        # inverse permutation
        ip[p[i]] = i
        return p, ip



    def _is_collinear(self, lons, lats):
        &#34;&#34;&#34;
        Checks if first three points are collinear - in the spherical
        case this corresponds to all points lying on a great circle
        and, hence, all coordinate vectors being in a single plane.
        &#34;&#34;&#34;

        x, y, z = lonlat2xyz(lons[:3], lats[:3])
        pts = np.column_stack([x, y, z])

        collinearity = (np.linalg.det(pts.T) == 0.0)

        return collinearity


    def _update_triangulation(self, lons, lats):

        npoints = len(lons)

        # We do this spherical -&gt; cartesian -&gt; spherical conversion
        # to protect against lons or lats being out of range.
        # (Only really an issue for refined meshes)
        xs, ys, zs = lonlat2xyz(lons, lats)
        lons, lats = xyz2lonlat(xs, ys, zs)

        # Deal with collinear issue

        if self.permute:
            # Store permutation vectors to shuffle/deshuffle lons and lats
            niter = 0
            ierr = -2
            while ierr==-2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                lons = lons[p]
                lats = lats[p]
                # compute cartesian coords on unit sphere.
                x, y, z = _stripack.trans(lats, lons)
                lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            # compute cartesian coords on unit sphere.
            x, y, z = _stripack.trans(lats, lons)
            lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._lons = lons
        self._lats = lats
        self._x = x
        self._y = y
        self._z = z
        self._points = np.column_stack([x, y, z])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # initialise dummy sigma array with zero tension factors
        self._sigma = np.zeros(self.lptr.size)

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _stripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        ## np.ndarray.sort(self.simplices, axis=1)

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

    @property
    def lons(self):
        &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lons)
    @property
    def lats(self):
        &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lats)
    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def z(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._z)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _shuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Permute ordering
        &#34;&#34;&#34;
        ip = self._invpermutation
        return ip[simplices]

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the lon / lat components of the gradient
        of a scalar field on the surface of the UNIT sphere.
        (Note: the companion routine is derivatives_lonlat which returns
        the components of the derivative in each direction - these differ by a factor of 
        1/cos(lat) in the first component)

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
            guarantee_convergence=guarantee_convergence, sigma=sigma)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        corr = np.sqrt((1.0-z**2))  
        valid = ~np.isclose(corr,0.0)
        dlon[valid] = dlon[valid] / corr[valid]

        return dlon, dlat


    def derivatives_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the lon / lat components of the derivatives
        of a scalar field on the surface of the UNIT sphere.
        (Note: the companion routine is gradient_lonlat which returns
        the components of the surface gradient - these differ by a factor of 
        1/cos(lat) in the first component)


        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
            guarantee_convergence=guarantee_convergence, sigma=sigma)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        return dlon, dlat




    def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the cartesian components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction
            dfdz : array of floats, shape (n,)
                derivative of f in the z direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
            derivative of F with respect to distance T along the arc.
        &#34;&#34;&#34;

        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=float32)
        sigma, iflgs = self._check_sigma(sigma)

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f,\
                                         self.lst, self.lptr, self.lend,\
                                         iflgs, sigma, nit, tol)
            if not guarantee_convergence:
                break

        import warnings

        if ierr &lt; 0:
            import warnings
            warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(grad[0], grad[1], grad[2])


    def smoothing(self, f, w, sm, smtol, gstol, sigma=None):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma, iflgs = self._check_sigma(sigma)
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f,\
                                              self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            print(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr



    def _check_integrity(self, lons, lats):
        &#34;&#34;&#34;
        Ensure lons and lats are:
         - 1D numpy arrays
         - equal size
         - within the appropriate range in radians
        &#34;&#34;&#34;

        lons = np.array(lons).ravel()
        lats = np.array(lats).ravel()

        if len(lons.shape) != 1 or len(lats.shape) != 1:
            raise ValueError(&#39;lons and lats must be 1D&#39;)
        if lats.size != lons.size:
            raise ValueError(&#39;lons and lats must have same length&#39;)
        if (np.abs(lons)).max() &gt; 2.*np.pi:
            raise ValueError(&#34;lons must be in radians (-2*pi &lt;= lon &lt;= 2*pi)&#34;)
        if (np.abs(lats)).max() &gt; 0.5*np.pi:
            raise ValueError(&#34;lats must be in radians (-pi/2 &lt;= lat &lt;= pi/2)&#34;)
        return lons, lats


    def _check_gradient(self, zdata, grad):
        &#34;&#34;&#34;
        Error checking on the gradient operator
        `grad` must be (3,n) array that is permuted
        iflgg = 0 if gradient should be estimated
        iflgg = 1 if gradient is provided
        &#34;&#34;&#34;
        p = self._permutation

        if grad is None:
            grad = np.empty((3,self.npoints))
            iflgg = 0

        elif grad.shape == (3,self.npoints):
            grad = grad[:,p] # permute
            iflgg = 1

        else:
            raise ValueError(&#34;gradient should be &#39;None&#39; or of shape (3,n).&#34;)

        return grad, iflgg


    def _check_sigma(self, sigma):
        &#34;&#34;&#34;
        Error checking on sigma
        `sigma` must be of length 6n-12.
        &#34;&#34;&#34;
        if sigma is None:
            iflgs = 0
            sigma = self._sigma
        else:
            assert len(sigma) == 6*self.npoints-12, &#34;sigma must be of length 6n-12&#34;
            iflgs = int(np.any(sigma))

        return sigma, iflgs


    def update_tension_factors(self, zdata, tol=1e-3, grad=None):
        &#34;&#34;&#34;
        WARNING: this is deprecated in favour of `get_spline_tension_factors`
        &#34;&#34;&#34;
        import warnings
        message = &#34;Use get_spline_tension_factors and supply tension factors to interpolation/gradient arrays&#34;
        message += &#34;\nsigma stored on this mesh object no longer does anything as of v2.0&#34;
        warnings.warn(message, DeprecationWarning, stacklevel=2)
        return self.get_spline_tension_factors(zdata, tol, grad)


    def get_spline_tension_factors(self, zdata, tol=1e-3, grad=None):
        &#34;&#34;&#34;
        Determines, for each triangulation arc, the smallest (nonnegative) tension factor `sigma`
        such that the Hermite interpolatory tension spline, defined by `sigma` and specified
        endpoint data, preserves local shape properties (monotonicity and convexity) of `zdata`.

        Args:
            zdata : array of floats, shape(n,)
                value at each point in the triangulation
                must be the same size of the mesh
            tol : float
                tolerance of each tension factor to its optimal value
                when nonzero finite tension is necessary.
            grad : array of floats, shape(3,n)
                precomputed gradient of zdata or if not provided,
                the result of `self.gradient(zdata)`.

        Returns:
            sigma : array of floats, shape(6n-12)
                tension factors which preserves the local properties of `zdata` on each
                triangulation arc with the restriction that `sigma[i] &lt;= 85`.

                - `sigma[i] = 85` if infinite tension is required on an arc.
                - `sigma[i] = 0` if the result should be cubic on the arc.

        Notes:
            Supply sigma to gradient, interpolate, derivative, or smoothing
            methods for tensioned splines. Here is a list of compatible methods:

            - `interpolate(lons, lats, zdata, order=3, grad=None, sigma=None)`
            - `interpolate_cubic(lons, lats, zdata, grad=None, sigma=None)`
            - `interpolate_to_grid(lons, lats, zdata, grad=None, sigma=None)`
            - `gradient_xyz(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
            - `gradient_lonlat(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
            - `smoothing(f, w, sm, smtol, gstol, sigma=None)`

        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        p = self._permutation
        zdata = self._shuffle_field(zdata)

        if grad is None:
            grad = np.vstack(self.gradient_xyz(zdata, tol=tol))
            grad = grad[:,p] # permute

        elif grad.shape == (3,self.npoints):
            grad = grad[:,p] # permute

        else:
            raise ValueError(&#34;gradient should be &#39;None&#39; or of shape (3,n).&#34;)

        sigma, dsmax, ierr = _ssrfpack.getsig(self._x, self._y, self._z, zdata,\
                                              self.lst, self.lptr, self.lend,\
                                              grad, tol)

        if ierr == -1:
            import warnings
            warnings.warn(&#34;sigma is not altered.&#34;)

        # self.sigma = sigma
        # self.iflgs = int(sigma.any())

        return sigma


    def interpolate_to_grid(self, lons, lats, zdata, grad=None, sigma=None):
        &#34;&#34;&#34;
        Interplates the data values to a uniform grid defined by
        longitude and latitudinal arrays. The interpolant is once
        continuously differentiable. Extrapolation is performed at
        grid points exterior to the triangulation when the nodes
        do not cover the entire sphere.

        Args:
            lons : array of floats, shape (ni,)
                longitudinal coordinates in ascending order
            lats : array of floats, shape (nj,)
                latitudinal coordinates in ascending order
            zdata : array of floats, shape(n,)
                value at each point in the triangulation
                must be the same size of the mesh
            grad : array of floats, shape(3,n)
                precomputed gradient of zdata or if not provided,
                the result of `self.gradient(zdata)`.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            zgrid : array of floats, shape(nj,ni)
                interpolated values defined by gridded lons/lats
        &#34;&#34;&#34;
        _emsg = {-1: &#34;n, ni, nj, or iflgg is outside its valid range.&#34;,\
                 -2: &#34;nodes are collinear.&#34;,\
                 -3: &#34;extrapolation failed due to the uniform grid extending \
                      too far beyond the triangulation boundary&#34;}


        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)
        grad, iflgg = self._check_gradient(zdata, grad)
        sigma, iflgs = self._check_sigma(sigma)
        
        nrow = len(lats)


        ff, ierr = _ssrfpack.unif(self._x, self._y, self._z, zdata,\
                                  self.lst, self.lptr, self.lend,\
                                  iflgs, sigma, nrow, lats, lons,\
                                  iflgg, grad)

        if ierr &lt; 0:
            raise ValueError(_emsg[ierr])

        return ff


    def interpolate(
        self,
        lons,
        lats,
        zdata,
        order=1,
        grad=None,
        sigma=None,
        threads=1,
    ):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes on the unit sphere, along with data
        values at the nodes, this method interpolates (or extrapolates) the value
        at a given longitude and latitude.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used

                - `order=0` = nearest-neighbour
                - `order=1` = linear
                - `order=3` = cubic

            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`
                (only used in cubic interpolation)

            threads : int or &#39;auto&#39;, optional; default : 1
                Number of threads to use for linear and nearest-neighbour
                interpolation (N.B. multi-threaded cubic interpolation is
                not supported).
                By default, only a single thread will be used. Use
                `threads=&#39;auto&#39;` to attempt to automatically determine how
                many threads to use based on the size of the input and output
                data.
                Negative values count backwards, such that -1 is equivalent to
                `multiprocessing.cpu_count()`, -2 to `cpu_count() - 1`, etc.

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) at (lons, lats)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;
        shape = np.shape(lons)

        lons, lats = self._check_integrity(lons, lats)
        n_in = np.size(zdata)
        n_out = np.size(lons)

        if n_in != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)

        if order not in {0, 1, 3}:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)
        if threads == 0:
            raise ValueError(&#34;threads must not be zero&#34;)

        if threads == &#34;auto&#34;:
            # Try to guess whether multiple threads would be helpful
            threads = _auto_threads(n_in, n_out, order)
        threads = int(threads)

        if order == 3 and threads != 1:
            import warnings

            warnings.warn(
                &#34;Multithreading not supported for cubic interpolation&#34;,
                RuntimeWarning,
            )
            threads = 1

        if threads &lt; 0:
            # -1 corresponds to cpu_count(), etc.
            threads = cpu_count() + threads + 1

        if threads == 1:
            if order == 3:
                sigma, iflgs = self._check_sigma(sigma)
                grad, iflgg = self._check_gradient(zdata, grad)

                zi, zierr, ierr = _ssrfpack.interp_cubic(lats, lons,
                                            self._x, self._y, self._z, zdata,
                                            self.lst, self.lptr, self.lend,
                                            iflgs, sigma, iflgg, grad)
            else:
                zi, zierr, ierr = _stripack.interp_n(order, lats, lons,
                                            self._x, self._y, self._z, zdata,
                                            self.lst, self.lptr, self.lend)

        else:
            # The following code is largely adapted from here:
            # https://numpy.org/doc/stable/reference/random/multithreading.html
            import concurrent.futures

            size = lons.size
            zi = np.full(size, np.nan)
            zierr = np.full(size, np.nan)
            ierr = np.full(threads, 0)
            step = np.ceil(size / threads).astype(np.int_)
            futures = {}
            executor = concurrent.futures.ThreadPoolExecutor(threads)

            def _f(
                out_zi,
                out_zierr,
                out_ierr,
                order,
                lats,
                lons,
                x,
                y,
                z,
                zdata,
                lst,
                lptr,
                lend,
                first,
                last,
                ierr_index,
            ):
                tmp_zi, tmp_zierr, tmp_ierr = _stripack.interp_n(
                    order, lats[first:last], lons[first:last],
                    x, y, z, zdata,
                    lst, lptr, lend,
                )
                out_zi[first:last] = tmp_zi
                out_zierr[first:last] = tmp_zierr
                out_ierr[ierr_index] = tmp_ierr

            for i in range(threads):
                first = i * step
                last = (i + 1) * step
                args = (
                    _f,
                    zi,
                    zierr,
                    ierr,
                    order,
                    lats,
                    lons,
                    self._x,
                    self._y,
                    self._z,
                    zdata,
                    self.lst,
                    self.lptr,
                    self.lend,
                    first,
                    last,
                    i,
                )
                futures[executor.submit(*args)] = i
            concurrent.futures.wait(futures)
            executor.shutdown(False)
            ierr = int((ierr != 0).any())

        if ierr != 0:
            import warnings
            warnings.warn(
                &#39;Warning some points may have errors - check error array&#39;,
                RuntimeWarning,
            )
            zi[zierr &lt; 0] = np.nan

        return zi.reshape(shape), zierr.reshape(shape)


    def interpolate_nearest(self, lons, lats, data, threads=1):
        &#34;&#34;&#34;
        Interpolate using nearest-neighbour approximation
        Returns the same as `interpolate(lons,lats,data,order=0)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=0, threads=threads)

    def interpolate_linear(self, lons, lats, data, threads=1):
        &#34;&#34;&#34;
        Interpolate using linear approximation
        Returns the same as `interpolate(lons,lats,data,order=1)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=1, threads=threads)

    def interpolate_cubic(
        self,
        lons,
        lats,
        data,
        grad=None,
        sigma=None,
        *,
        threads=1,  # currently unused; provided for API consistency
    ):
        &#34;&#34;&#34;
        Interpolate using cubic spline approximation
        Returns the same as `interpolate(lons,lats,data,order=3)`
        &#34;&#34;&#34;
        return self.interpolate(
            lons,
            lats,
            data,
            order=3,
            grad=grad,
            sigma=sigma,
            threads=1,
        )


    def neighbour_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex.
        The kth neighbour is opposite to the kth vertex.
        For simplices at the boundary, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        return ltri.T[:nt,3:] - 1

    def neighbour_and_arc_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex and arc indices.
        Identical to get_neighbour_simplices() but also returns an array
        of indices that reside on boundary hull, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        ltri = ltri.T[:nt] - 1
        return ltri[:,3:6], ltri[:,6:]


    def nearest_vertex(self, lons, lats):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (lons,lats)
        and return the squared great circle distance between (lons,lats) and
        each nearest neighbour.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                great circle distance (angle) on the unit sphere to the closest
                vertex identified.

        Notes:
            Faster searches can be obtained using a k-d tree.
            See `sTriangulation.nearest_vertices()` for details.
            There is an additional overhead associated with building and storing the k-d tree.

        &#34;&#34;&#34;

        # translate to unit sphere

        xi = np.array(_stripack.trans(lats, lons))
        idx = np.empty_like(xi[0,:], dtype=int)
        dist = np.empty_like(xi[0,:], dtype=float)

        for pt in range(0, xi.shape[1]):
            xi0 = xi[:,pt]

            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = ((self._x - xi0[0])**2).argmin() + 1

            idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, lons, lats):
        &#34;&#34;&#34;
        Returns indices of the triangles containing lons / lats.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            tri_indices : array of ints, shape (l,)
                indices of containing triangle


        Notes:
            The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

        &#34;&#34;&#34;
        p = self._permutation
        pts = np.array(lonlat2xyz(lons,lats)).T

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri = np.sort(t[3:6]) - 1

            triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).reshape(-1)


    def containing_simplex_and_bcc(self, lons, lats):
        &#34;&#34;&#34;
        Returns the simplices containing (lons,lats)
        and the local barycentric, normalised coordinates.

        Args:
            lons : float / array of floats, shape(l,)
                longitudinal coordinates in radians
            lats :  float / array of floats, shape(l,)
                latitudinal coordinates in radians

        Returns:
            bcc  : normalised barycentric coordinates
            tri  : simplicies containing (lons,lats)

        Notes:
            That the ordering of the vertices may differ from
            that stored in the self.simplices array but will
            still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.array(lonlat2xyz(lons,lats)).T

        tri = np.empty((pts.shape[0], 3), dtype=int) # simplices
        bcc = np.empty_like(tri, dtype=float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri[i] = t[3:6]
            bcc[i] = t[0:3]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        (from the data structures of the triangulation)
        &#34;&#34;&#34;
        vertex = self._permutation[vertex]

        lpl = self.lend[vertex-1]
        lp = lpl

        neighbours = []

        while True:
            lp = self.lptr[lp-1]
            neighbours.append(np.abs(self.lst[lp-1])-1)
            if (lp == lpl):
                break

        return self._deshuffle_simplices(neighbours)


    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))



    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        lst  = self.lst
        lend = self.lend
        lptr = self.lptr

        segments_array = np.empty((len(lptr),2),dtype=int)
        segments_array[:,0] = lst[:] - 1
        segments_array[:,1] = lst[lptr[:]-1] - 1

        valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
        segments = segments_array[valid,:]

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoint_lonlats = self.segment_midpoints(segments=segs)

        return new_midpoint_lonlats


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlons, midlats


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned. Note,
        segments in the array must not be duplicates or the re-triangulation
        will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return lons, lats

    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
        mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

        mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
        mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

        mids = np.vstack((mids1,mids2))

        midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlls


    def lons_map_to_wrapped(self, lon):

        lons = np.array(lon)
        lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

        return lons

    def tri_area(self, lons, lats):
        &#34;&#34;&#34;
        Calculate the area enclosed by 3 points on the unit sphere.

        Args:
            lons : array of floats, shape (3)
                longitudinal coordinates in radians
            lats : array of floats, shape (3)
                latitudinal coordinates in radians

        Returns:
            area : float
                area of triangle on the unit sphere

        &#34;&#34;&#34;
        lons, lats = self._check_integrity(lons, lats)

        # translate to unit sphere
        x, y, z = _stripack.trans(lats, lons)

        # compute area
        area = _stripack.areas(x, y, z)

        return area



    def areas(self):
        &#34;&#34;&#34;
        Compute the area each triangle within the triangulation of points
        on the unit sphere.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in self.simplices where nt
                is the number of triangles.

        Notes:
            This uses a Fortran 90 subroutine that wraps the AREA function
            to iterate over many points.
        &#34;&#34;&#34;

        return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;

        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        ## dot products to obtain angles
        ab = np.arccos((a * b).sum(axis=1))
        bc = np.arccos((b * c).sum(axis=1))
        ac = np.arccos((a * c).sum(axis=1))

        ## As this is a unit sphere, angle = length so ...

        return ab, bc, ac

    def angular_separation(self, lonp1, latp1, lonp2, latp2):
        &#34;&#34;&#34;
        Compute the angles between lon / lat points p1 and p2 given in radians.
        On the unit sphere, this also corresponds to the great circle distance.
        p1 and p2 can be numpy arrays of the same length.

        This method simply calls the module-level function of the same name.
        Consider using the module function instead, as this method may be
        deprecated in favor of that function. For now, this method is
        retained to avoid issues with the Jupyter notebooks.
        &#34;&#34;&#34;
        # Call the module-level function
        return angular_separation(lonp1, latp1, lonp2, latp2)

    def _add_spherical_midpoints(self):

        midlon_array, midlat_array = self.segment_midpoints()

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_spherical_tripoints(self, ratio=0.333333):

        midlon_array, midlat_array = self.segment_tripoints(ratio=ratio)

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_face_centroids(self):

        facelon_array, facelat_array = self.face_midpoints()

        lonv2 = np.concatenate((self.lons, facelon_array), axis=0)
        latv2 = np.concatenate((self.lats, facelat_array), axis=0)

        return lonv2, latv2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            lonv1, latv1 = self._add_face_centroids()

        else:
            if not trisect:
                lonv1, latv1 = self._add_spherical_midpoints()
            else:
                lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


        return lonv1, latv1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1




    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i].`
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        mlons, mlats = self.segment_midpoints(segs)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)



    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by adding the
        face centroids of the triangles in the list of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by adding the
        face centroids in the triangulation connected to any of the vertices in
        the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)



    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=True to skip the testing and duplicate removal
        &#34;&#34;&#34;

        lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
        latv1 = np.concatenate((self.lats, t2.lats), axis=0)

        ## remove any duplicates

        if not unique:
            lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

        return lonv1, latv1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree =  scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            lon : 1D array
                longitudinal coordinates in radians
            lat : 1D array
                latitudinal coordinates in radians
            k : int (default: 1)
                number of nearest neighbours to return
            max_distance : float (default: 2.0)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        lons = np.array(lon).reshape(-1,1)
        lats = np.array(lat).reshape(-1,1)

        xyz = np.empty((lons.shape[0],3))
        x,y,z = lonlat2xyz(lons, lats)

        xyz[:,0] = x[:].reshape(-1)
        xyz[:,1] = y[:].reshape(-1)
        xyz[:,2] = z[:].reshape(-1)

        dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        ## Now find the angular separation / great circle distance: dlatlon


        vertxyz = self.points[vertices].transpose(0,2,1)
        extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

        angles = np.arccos((extxyz * vertxyz).sum(axis=1))

        return angles, vertices


    def voronoi_points(self, return_circumradius=False):
        &#34;&#34;&#34;
        Calculates the voronoi points from the triangulation.

        This routine returns the circumcentre, circumradius of each triangle.

        Args:
            return_circumradius : bool
                optionally return circumradius of each circumcentre

        Returns:
            vlons : ndarray of floats
                longitudinal coordinates of the Voronoi
            vlats : ndarray of floats
                latitudinal coordinates of the Voronoi
            cr : ndarray of floats (optional)
                coordinates of the circumcentre (centre of the circle
                defined by three points in a triangle)
        &#34;&#34;&#34;

        # get x,y,z coordinates for each triangle
        simplices = self.simplices
        xt = self.x[simplices]
        yt = self.y[simplices]
        zt = self.z[simplices]

        # construct 3-component vectors
        v1 = np.column_stack([xt[:,0], yt[:,0], zt[:,0]])
        v2 = np.column_stack([xt[:,1], yt[:,1], zt[:,1]])
        v3 = np.column_stack([xt[:,2], yt[:,2], zt[:,2]])

        # get edge lengths
        e1 = v2 - v1
        e2 = v3 - v1

        # compute scalar multiples of e1 * e2
        cu = np.empty_like(xt)
        cu[:,0] = e1[:,1]*e2[:,2] - e1[:,2]*e2[:,1]
        cu[:,1] = e1[:,2]*e2[:,0] - e1[:,0]*e2[:,2]
        cu[:,2] = e1[:,0]*e2[:,1] - e1[:,1]*e2[:,0]

        # compute normal vector
        cnorm = np.sqrt( (cu**2).sum(axis=1) )

        coords = cu / cnorm.reshape(-1,1)
        xc, yc, zc = coords[:,0], coords[:,1], coords[:,2]

        # convert to lon/lat
        vlons, vlats = xyz2lonlat(xc,yc,zc)

        out = [vlons, vlats]

        if return_circumradius:
            tr = (v1*coords).sum(axis=1)
            tr = np.clip(tr, -1.0, 1.0)
            cr = np.arccos(tr)
            out.append( cr )

        return tuple(out)

    def voronoi_points_and_regions(self):
        &#34;&#34;&#34;
        Calculates the voronoi points from the triangulation
        and constructs the region enclosed by them.

        Returns:
            vlons : ndarray of floats
                longitudinal coordinates of the Voronoi
            vlats : ndarray of floats
                latitudinal coordinates of the Voronoi
            regions : list of ints
                a nested list of all Voronoi indices that
                enclose a region.

        Notes:
            Inifinite regions are not indicated.
        &#34;&#34;&#34;

        vx, vy = self.voronoi_points()

        # store these to avoid any shuffle/reshuffle later
        simplices = self.simplices
        x = self.lons
        y = self.lats

        # empty placeholder array for vertices
        voronoi_regions = [[] for i in range(0, self.npoints)]

        # create regions for each point in the Delaunay triangulation
        for i, (t0,t1,t2) in enumerate(simplices):
            voronoi_regions[t0].append(i)
            voronoi_regions[t1].append(i)
            voronoi_regions[t2].append(i)

        # sort the vertices around each site
        # there is probably a more efficient way using the neighbour adjacency info
        for i in range(0, self.npoints):
            region = np.array(voronoi_regions[i])
            dx = vx[region] - x[i]
            dy = vy[region] - y[i]
            idx = np.arctan2(dx, dy).argsort() # this could be a problem across the dateline
            voronoi_regions[i] = region[idx]

        return vx, vy, voronoi_regions



## Helper functions for the module

def remove_duplicate_lonlat(lon, lat):
    &#34;&#34;&#34;
    remove duplicates from an array of lon / lat points
    &#34;&#34;&#34;

    a = np.ascontiguousarray(np.vstack((lon, lat)).T)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    llunique = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

    lon1 = llunique[:,0]
    lat1 = llunique[:,1]

    return lon1, lat1


def lonlat2xyz(lon, lat):
    &#34;&#34;&#34;
    Convert lon / lat (radians) for the spherical triangulation into x,y,z
    on the unit sphere
    &#34;&#34;&#34;

    lons = np.array(lon)
    lats = np.array(lat)

    xs,ys,zs = _stripack.trans(lats, lons)

    return xs, ys, zs

def xyz2lonlat(x,y,z):
    &#34;&#34;&#34;
    Convert x,y,z representation of points *on the unit sphere* of the
    spherical triangulation to lon / lat (radians).

    Notes:
        no check is made here that (x,y,z) are unit vectors
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arctan2(zs, np.hypot(ys, xs))

    return lons, lats


def dxyz2dlonlat(x,y,z, dfx, dfy, dfz):
    &#34;&#34;&#34;
    Take stripack df/dx, df/dy, df/dz format and convert to
    surface gradients df/dlon, df/dlat
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arctan2(zs, np.hypot(ys, xs))

    dfxs = np.array(dfx)
    dfys = np.array(dfy)
    dfzs = np.array(dfz)

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-zs**2))
    valid = ~np.isclose(corr,0.0)

    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat


def great_circle_Npoints(lonlat1r, lonlat2r, N):
    &#34;&#34;&#34;
    N points along the line joining lonlat1 and lonlat2
    &#34;&#34;&#34;

    ratio = np.linspace(0.0,1.0, N).reshape(-1,1)

    xyz1 = np.array(lonlat2xyz(lonlat1r[0], lonlat1r[1])).T
    xyz2 = np.array(lonlat2xyz(lonlat2r[0], lonlat2r[1])).T

    mids = ratio * xyz2 + (1.0-ratio) * xyz1
    norm = np.sqrt((mids**2).sum(axis=1))
    xyzN = mids / norm.reshape(-1,1)

    lonlatN = xyz2lonlat( xyzN[:,0], xyzN[:,1], xyzN[:,2])

    return lonlatN


def angular_separation(lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.
    &#34;&#34;&#34;

    xp1, yp1, zp1 = lonlat2xyz(lonp1, latp1)
    xp2, yp2, zp2 = lonlat2xyz(lonp2, latp2)

    ## dot products to obtain angles

    angles = np.arccos((xp1 * xp2 + yp1 * yp2 + zp1 * zp2))

    ## As this is a unit sphere, angle = length

    return angles</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stripy.spherical.angular_separation"><code class="name flex">
<span>def <span class="ident">angular_separation</span></span>(<span>lonp1, latp1, lonp2, latp2)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angles between lon / lat points p1 and p2 given in radians.
On the unit sphere, this also corresponds to the great circle distance.
p1 and p2 can be numpy arrays of the same length.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_separation(lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.
    &#34;&#34;&#34;

    xp1, yp1, zp1 = lonlat2xyz(lonp1, latp1)
    xp2, yp2, zp2 = lonlat2xyz(lonp2, latp2)

    ## dot products to obtain angles

    angles = np.arccos((xp1 * xp2 + yp1 * yp2 + zp1 * zp2))

    ## As this is a unit sphere, angle = length

    return angles</code></pre>
</details>
</dd>
<dt id="stripy.spherical.dxyz2dlonlat"><code class="name flex">
<span>def <span class="ident">dxyz2dlonlat</span></span>(<span>x, y, z, dfx, dfy, dfz)</span>
</code></dt>
<dd>
<div class="desc"><p>Take stripack df/dx, df/dy, df/dz format and convert to
surface gradients df/dlon, df/dlat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dxyz2dlonlat(x,y,z, dfx, dfy, dfz):
    &#34;&#34;&#34;
    Take stripack df/dx, df/dy, df/dz format and convert to
    surface gradients df/dlon, df/dlat
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arctan2(zs, np.hypot(ys, xs))

    dfxs = np.array(dfx)
    dfys = np.array(dfy)
    dfzs = np.array(dfz)

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-zs**2))
    valid = ~np.isclose(corr,0.0)

    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat</code></pre>
</details>
</dd>
<dt id="stripy.spherical.great_circle_Npoints"><code class="name flex">
<span>def <span class="ident">great_circle_Npoints</span></span>(<span>lonlat1r, lonlat2r, N)</span>
</code></dt>
<dd>
<div class="desc"><p>N points along the line joining lonlat1 and lonlat2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def great_circle_Npoints(lonlat1r, lonlat2r, N):
    &#34;&#34;&#34;
    N points along the line joining lonlat1 and lonlat2
    &#34;&#34;&#34;

    ratio = np.linspace(0.0,1.0, N).reshape(-1,1)

    xyz1 = np.array(lonlat2xyz(lonlat1r[0], lonlat1r[1])).T
    xyz2 = np.array(lonlat2xyz(lonlat2r[0], lonlat2r[1])).T

    mids = ratio * xyz2 + (1.0-ratio) * xyz1
    norm = np.sqrt((mids**2).sum(axis=1))
    xyzN = mids / norm.reshape(-1,1)

    lonlatN = xyz2lonlat( xyzN[:,0], xyzN[:,1], xyzN[:,2])

    return lonlatN</code></pre>
</details>
</dd>
<dt id="stripy.spherical.lonlat2xyz"><code class="name flex">
<span>def <span class="ident">lonlat2xyz</span></span>(<span>lon, lat)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert lon / lat (radians) for the spherical triangulation into x,y,z
on the unit sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lonlat2xyz(lon, lat):
    &#34;&#34;&#34;
    Convert lon / lat (radians) for the spherical triangulation into x,y,z
    on the unit sphere
    &#34;&#34;&#34;

    lons = np.array(lon)
    lats = np.array(lat)

    xs,ys,zs = _stripack.trans(lats, lons)

    return xs, ys, zs</code></pre>
</details>
</dd>
<dt id="stripy.spherical.remove_duplicate_lonlat"><code class="name flex">
<span>def <span class="ident">remove_duplicate_lonlat</span></span>(<span>lon, lat)</span>
</code></dt>
<dd>
<div class="desc"><p>remove duplicates from an array of lon / lat points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_duplicate_lonlat(lon, lat):
    &#34;&#34;&#34;
    remove duplicates from an array of lon / lat points
    &#34;&#34;&#34;

    a = np.ascontiguousarray(np.vstack((lon, lat)).T)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    llunique = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

    lon1 = llunique[:,0]
    lat1 = llunique[:,1]

    return lon1, lat1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.xyz2lonlat"><code class="name flex">
<span>def <span class="ident">xyz2lonlat</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert x,y,z representation of points <em>on the unit sphere</em> of the
spherical triangulation to lon / lat (radians).</p>
<h2 id="notes">Notes</h2>
<p>no check is made here that (x,y,z) are unit vectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz2lonlat(x,y,z):
    &#34;&#34;&#34;
    Convert x,y,z representation of points *on the unit sphere* of the
    spherical triangulation to lon / lat (radians).

    Notes:
        no check is made here that (x,y,z) are unit vectors
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arctan2(zs, np.hypot(ys, xs))

    return lons, lats</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stripy.spherical.sTriangulation"><code class="flex name class">
<span>class <span class="ident">sTriangulation</span></span>
<span>(</span><span>lons, lats, refinement_levels=0, permute=False, tree=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Define a Delaunay triangulation for given points on a sphere
where lons and lats are 1D numpy arrays of equal length.</p>
<h2 id="algorithm">Algorithm</h2>
<p>R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
and Voronoi diagram on the surface of a sphere"
ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
doi:10.1145/275323.275329</p>
<h2 id="args">Args</h2>
<p>lons : 1D array
longitudinal coordinates in radians
lats : 1D array
latitudinal coordinates in radians
refinement_levels : int
refine the number of points in the triangulation
(see uniformly_refine_triangulation)
permute : bool
randomises the order of lons and lats to improve
triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)
tree : bool
construct a cKDtree for efficient nearest-neighbour lookup</p>
<h2 id="attributes">Attributes</h2>
<p>lons : array of floats, shape (n,)
stored longitudinal coordinates on a sphere
lats : array of floats, shape (n,)
stored latitudinal coordinates on a sphere
x : array of floats, shape (n,)
stored Cartesian x coordinates from input
y : array of floats, shape (n,)
stored Cartesian y coordinates from input
z : array of floats, shape (n,)
stored Cartesian z coordinates from input
simplices : array of ints, shape (nsimplex, 3)
indices of the points forming the simplices in the triangulation
points are ordered anticlockwise
lst : array of ints, shape (6n-12,)
nodal indices with lptr and lend, define the triangulation as a set of N
adjacency lists; counterclockwise-ordered sequences of neighboring nodes
such that the first and last neighbors of a boundary node are boundary
nodes (the first neighbor of an interior node is arbitrary).
In order to
distinguish between interior and boundary nodes, the last neighbor of
each boundary node is represented by the negative of its index.
The indices are 1-based (as in Fortran), not zero based (as in python).
lptr : array of ints, shape (6n-12),)
set of pointers in one-to-one correspondence with the elements of lst.
lst(lptr(i)) indexes the node which follows lst(i) in cyclical
counterclockwise order (the first neighbor follows the last neighbor).
The indices are 1-based (as in Fortran), not zero based (as in python).
lend : array of ints, shape (n,)
N pointers to adjacency lists.
lend(k) points to the last neighbor of node K.
lst(lend(K)) &lt; 0 if and only if K is a boundary node.
The indices are 1-based (as in Fortran), not zero based (as in python).</p>
<h2 id="notes">Notes</h2>
<p>Provided the nodes are randomly ordered, the algorithm
has expected time complexity O(N<em>log(N)) for most nodal
distributions.
Note, however, that the complexity may be
as high as O(N</em>*2) if, for example, the nodes are ordered
on increasing latitude.</p>
<p>if permute=True, lons and lats are randomised on input before
they are triangulated. The distribution of triangles will
differ between setting permute=True and permute=False,
however, the node ordering will remain identical.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sTriangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given points on a sphere
    where lons and lats are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
        and Voronoi diagram on the surface of a sphere&#34;
        ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
        doi:10.1145/275323.275329

    Args:
        lons : 1D array
            longitudinal coordinates in radians
        lats : 1D array
            latitudinal coordinates in radians
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        lons : array of floats, shape (n,)
            stored longitudinal coordinates on a sphere
        lats : array of floats, shape (n,)
            stored latitudinal coordinates on a sphere
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        z : array of floats, shape (n,)
            stored Cartesian z coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity O(N*log(N)) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as O(N**2) if, for example, the nodes are ordered
        on increasing latitude.

        if permute=True, lons and lats are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting permute=True and permute=False,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, lons, lats, refinement_levels=0, permute=False, tree=False):

        # lons, lats = self._check_integrity(lons, lats)
        self.permute = permute
        self.tree = tree

        self._update_triangulation(lons, lats)

        for r in range(0,refinement_levels):
            lons, lats = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(lons,lats)

        return

    def _generate_permutation(self, npoints):
        &#34;&#34;&#34;
        Create shuffle and deshuffle vectors
        &#34;&#34;&#34;
        i = np.arange(0, npoints)
        # permutation
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        # inverse permutation
        ip[p[i]] = i
        return p, ip



    def _is_collinear(self, lons, lats):
        &#34;&#34;&#34;
        Checks if first three points are collinear - in the spherical
        case this corresponds to all points lying on a great circle
        and, hence, all coordinate vectors being in a single plane.
        &#34;&#34;&#34;

        x, y, z = lonlat2xyz(lons[:3], lats[:3])
        pts = np.column_stack([x, y, z])

        collinearity = (np.linalg.det(pts.T) == 0.0)

        return collinearity


    def _update_triangulation(self, lons, lats):

        npoints = len(lons)

        # We do this spherical -&gt; cartesian -&gt; spherical conversion
        # to protect against lons or lats being out of range.
        # (Only really an issue for refined meshes)
        xs, ys, zs = lonlat2xyz(lons, lats)
        lons, lats = xyz2lonlat(xs, ys, zs)

        # Deal with collinear issue

        if self.permute:
            # Store permutation vectors to shuffle/deshuffle lons and lats
            niter = 0
            ierr = -2
            while ierr==-2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                lons = lons[p]
                lats = lats[p]
                # compute cartesian coords on unit sphere.
                x, y, z = _stripack.trans(lats, lons)
                lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            # compute cartesian coords on unit sphere.
            x, y, z = _stripack.trans(lats, lons)
            lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._lons = lons
        self._lats = lats
        self._x = x
        self._y = y
        self._z = z
        self._points = np.column_stack([x, y, z])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # initialise dummy sigma array with zero tension factors
        self._sigma = np.zeros(self.lptr.size)

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _stripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        ## np.ndarray.sort(self.simplices, axis=1)

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

    @property
    def lons(self):
        &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lons)
    @property
    def lats(self):
        &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lats)
    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def z(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._z)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _shuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Permute ordering
        &#34;&#34;&#34;
        ip = self._invpermutation
        return ip[simplices]

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the lon / lat components of the gradient
        of a scalar field on the surface of the UNIT sphere.
        (Note: the companion routine is derivatives_lonlat which returns
        the components of the derivative in each direction - these differ by a factor of 
        1/cos(lat) in the first component)

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
            guarantee_convergence=guarantee_convergence, sigma=sigma)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        corr = np.sqrt((1.0-z**2))  
        valid = ~np.isclose(corr,0.0)
        dlon[valid] = dlon[valid] / corr[valid]

        return dlon, dlat


    def derivatives_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the lon / lat components of the derivatives
        of a scalar field on the surface of the UNIT sphere.
        (Note: the companion routine is gradient_lonlat which returns
        the components of the surface gradient - these differ by a factor of 
        1/cos(lat) in the first component)


        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
            guarantee_convergence=guarantee_convergence, sigma=sigma)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        return dlon, dlat




    def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None):
        &#34;&#34;&#34;
        Return the cartesian components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction
            dfdz : array of floats, shape (n,)
                derivative of f in the z direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
            derivative of F with respect to distance T along the arc.
        &#34;&#34;&#34;

        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=float32)
        sigma, iflgs = self._check_sigma(sigma)

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f,\
                                         self.lst, self.lptr, self.lend,\
                                         iflgs, sigma, nit, tol)
            if not guarantee_convergence:
                break

        import warnings

        if ierr &lt; 0:
            import warnings
            warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(grad[0], grad[1], grad[2])


    def smoothing(self, f, w, sm, smtol, gstol, sigma=None):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma, iflgs = self._check_sigma(sigma)
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f,\
                                              self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            print(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr



    def _check_integrity(self, lons, lats):
        &#34;&#34;&#34;
        Ensure lons and lats are:
         - 1D numpy arrays
         - equal size
         - within the appropriate range in radians
        &#34;&#34;&#34;

        lons = np.array(lons).ravel()
        lats = np.array(lats).ravel()

        if len(lons.shape) != 1 or len(lats.shape) != 1:
            raise ValueError(&#39;lons and lats must be 1D&#39;)
        if lats.size != lons.size:
            raise ValueError(&#39;lons and lats must have same length&#39;)
        if (np.abs(lons)).max() &gt; 2.*np.pi:
            raise ValueError(&#34;lons must be in radians (-2*pi &lt;= lon &lt;= 2*pi)&#34;)
        if (np.abs(lats)).max() &gt; 0.5*np.pi:
            raise ValueError(&#34;lats must be in radians (-pi/2 &lt;= lat &lt;= pi/2)&#34;)
        return lons, lats


    def _check_gradient(self, zdata, grad):
        &#34;&#34;&#34;
        Error checking on the gradient operator
        `grad` must be (3,n) array that is permuted
        iflgg = 0 if gradient should be estimated
        iflgg = 1 if gradient is provided
        &#34;&#34;&#34;
        p = self._permutation

        if grad is None:
            grad = np.empty((3,self.npoints))
            iflgg = 0

        elif grad.shape == (3,self.npoints):
            grad = grad[:,p] # permute
            iflgg = 1

        else:
            raise ValueError(&#34;gradient should be &#39;None&#39; or of shape (3,n).&#34;)

        return grad, iflgg


    def _check_sigma(self, sigma):
        &#34;&#34;&#34;
        Error checking on sigma
        `sigma` must be of length 6n-12.
        &#34;&#34;&#34;
        if sigma is None:
            iflgs = 0
            sigma = self._sigma
        else:
            assert len(sigma) == 6*self.npoints-12, &#34;sigma must be of length 6n-12&#34;
            iflgs = int(np.any(sigma))

        return sigma, iflgs


    def update_tension_factors(self, zdata, tol=1e-3, grad=None):
        &#34;&#34;&#34;
        WARNING: this is deprecated in favour of `get_spline_tension_factors`
        &#34;&#34;&#34;
        import warnings
        message = &#34;Use get_spline_tension_factors and supply tension factors to interpolation/gradient arrays&#34;
        message += &#34;\nsigma stored on this mesh object no longer does anything as of v2.0&#34;
        warnings.warn(message, DeprecationWarning, stacklevel=2)
        return self.get_spline_tension_factors(zdata, tol, grad)


    def get_spline_tension_factors(self, zdata, tol=1e-3, grad=None):
        &#34;&#34;&#34;
        Determines, for each triangulation arc, the smallest (nonnegative) tension factor `sigma`
        such that the Hermite interpolatory tension spline, defined by `sigma` and specified
        endpoint data, preserves local shape properties (monotonicity and convexity) of `zdata`.

        Args:
            zdata : array of floats, shape(n,)
                value at each point in the triangulation
                must be the same size of the mesh
            tol : float
                tolerance of each tension factor to its optimal value
                when nonzero finite tension is necessary.
            grad : array of floats, shape(3,n)
                precomputed gradient of zdata or if not provided,
                the result of `self.gradient(zdata)`.

        Returns:
            sigma : array of floats, shape(6n-12)
                tension factors which preserves the local properties of `zdata` on each
                triangulation arc with the restriction that `sigma[i] &lt;= 85`.

                - `sigma[i] = 85` if infinite tension is required on an arc.
                - `sigma[i] = 0` if the result should be cubic on the arc.

        Notes:
            Supply sigma to gradient, interpolate, derivative, or smoothing
            methods for tensioned splines. Here is a list of compatible methods:

            - `interpolate(lons, lats, zdata, order=3, grad=None, sigma=None)`
            - `interpolate_cubic(lons, lats, zdata, grad=None, sigma=None)`
            - `interpolate_to_grid(lons, lats, zdata, grad=None, sigma=None)`
            - `gradient_xyz(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
            - `gradient_lonlat(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
            - `smoothing(f, w, sm, smtol, gstol, sigma=None)`

        &#34;&#34;&#34;

        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        p = self._permutation
        zdata = self._shuffle_field(zdata)

        if grad is None:
            grad = np.vstack(self.gradient_xyz(zdata, tol=tol))
            grad = grad[:,p] # permute

        elif grad.shape == (3,self.npoints):
            grad = grad[:,p] # permute

        else:
            raise ValueError(&#34;gradient should be &#39;None&#39; or of shape (3,n).&#34;)

        sigma, dsmax, ierr = _ssrfpack.getsig(self._x, self._y, self._z, zdata,\
                                              self.lst, self.lptr, self.lend,\
                                              grad, tol)

        if ierr == -1:
            import warnings
            warnings.warn(&#34;sigma is not altered.&#34;)

        # self.sigma = sigma
        # self.iflgs = int(sigma.any())

        return sigma


    def interpolate_to_grid(self, lons, lats, zdata, grad=None, sigma=None):
        &#34;&#34;&#34;
        Interplates the data values to a uniform grid defined by
        longitude and latitudinal arrays. The interpolant is once
        continuously differentiable. Extrapolation is performed at
        grid points exterior to the triangulation when the nodes
        do not cover the entire sphere.

        Args:
            lons : array of floats, shape (ni,)
                longitudinal coordinates in ascending order
            lats : array of floats, shape (nj,)
                latitudinal coordinates in ascending order
            zdata : array of floats, shape(n,)
                value at each point in the triangulation
                must be the same size of the mesh
            grad : array of floats, shape(3,n)
                precomputed gradient of zdata or if not provided,
                the result of `self.gradient(zdata)`.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            zgrid : array of floats, shape(nj,ni)
                interpolated values defined by gridded lons/lats
        &#34;&#34;&#34;
        _emsg = {-1: &#34;n, ni, nj, or iflgg is outside its valid range.&#34;,\
                 -2: &#34;nodes are collinear.&#34;,\
                 -3: &#34;extrapolation failed due to the uniform grid extending \
                      too far beyond the triangulation boundary&#34;}


        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)
        grad, iflgg = self._check_gradient(zdata, grad)
        sigma, iflgs = self._check_sigma(sigma)
        
        nrow = len(lats)


        ff, ierr = _ssrfpack.unif(self._x, self._y, self._z, zdata,\
                                  self.lst, self.lptr, self.lend,\
                                  iflgs, sigma, nrow, lats, lons,\
                                  iflgg, grad)

        if ierr &lt; 0:
            raise ValueError(_emsg[ierr])

        return ff


    def interpolate(
        self,
        lons,
        lats,
        zdata,
        order=1,
        grad=None,
        sigma=None,
        threads=1,
    ):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes on the unit sphere, along with data
        values at the nodes, this method interpolates (or extrapolates) the value
        at a given longitude and latitude.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used

                - `order=0` = nearest-neighbour
                - `order=1` = linear
                - `order=3` = cubic

            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`
                (only used in cubic interpolation)

            threads : int or &#39;auto&#39;, optional; default : 1
                Number of threads to use for linear and nearest-neighbour
                interpolation (N.B. multi-threaded cubic interpolation is
                not supported).
                By default, only a single thread will be used. Use
                `threads=&#39;auto&#39;` to attempt to automatically determine how
                many threads to use based on the size of the input and output
                data.
                Negative values count backwards, such that -1 is equivalent to
                `multiprocessing.cpu_count()`, -2 to `cpu_count() - 1`, etc.

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) at (lons, lats)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;
        shape = np.shape(lons)

        lons, lats = self._check_integrity(lons, lats)
        n_in = np.size(zdata)
        n_out = np.size(lons)

        if n_in != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)

        if order not in {0, 1, 3}:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)
        if threads == 0:
            raise ValueError(&#34;threads must not be zero&#34;)

        if threads == &#34;auto&#34;:
            # Try to guess whether multiple threads would be helpful
            threads = _auto_threads(n_in, n_out, order)
        threads = int(threads)

        if order == 3 and threads != 1:
            import warnings

            warnings.warn(
                &#34;Multithreading not supported for cubic interpolation&#34;,
                RuntimeWarning,
            )
            threads = 1

        if threads &lt; 0:
            # -1 corresponds to cpu_count(), etc.
            threads = cpu_count() + threads + 1

        if threads == 1:
            if order == 3:
                sigma, iflgs = self._check_sigma(sigma)
                grad, iflgg = self._check_gradient(zdata, grad)

                zi, zierr, ierr = _ssrfpack.interp_cubic(lats, lons,
                                            self._x, self._y, self._z, zdata,
                                            self.lst, self.lptr, self.lend,
                                            iflgs, sigma, iflgg, grad)
            else:
                zi, zierr, ierr = _stripack.interp_n(order, lats, lons,
                                            self._x, self._y, self._z, zdata,
                                            self.lst, self.lptr, self.lend)

        else:
            # The following code is largely adapted from here:
            # https://numpy.org/doc/stable/reference/random/multithreading.html
            import concurrent.futures

            size = lons.size
            zi = np.full(size, np.nan)
            zierr = np.full(size, np.nan)
            ierr = np.full(threads, 0)
            step = np.ceil(size / threads).astype(np.int_)
            futures = {}
            executor = concurrent.futures.ThreadPoolExecutor(threads)

            def _f(
                out_zi,
                out_zierr,
                out_ierr,
                order,
                lats,
                lons,
                x,
                y,
                z,
                zdata,
                lst,
                lptr,
                lend,
                first,
                last,
                ierr_index,
            ):
                tmp_zi, tmp_zierr, tmp_ierr = _stripack.interp_n(
                    order, lats[first:last], lons[first:last],
                    x, y, z, zdata,
                    lst, lptr, lend,
                )
                out_zi[first:last] = tmp_zi
                out_zierr[first:last] = tmp_zierr
                out_ierr[ierr_index] = tmp_ierr

            for i in range(threads):
                first = i * step
                last = (i + 1) * step
                args = (
                    _f,
                    zi,
                    zierr,
                    ierr,
                    order,
                    lats,
                    lons,
                    self._x,
                    self._y,
                    self._z,
                    zdata,
                    self.lst,
                    self.lptr,
                    self.lend,
                    first,
                    last,
                    i,
                )
                futures[executor.submit(*args)] = i
            concurrent.futures.wait(futures)
            executor.shutdown(False)
            ierr = int((ierr != 0).any())

        if ierr != 0:
            import warnings
            warnings.warn(
                &#39;Warning some points may have errors - check error array&#39;,
                RuntimeWarning,
            )
            zi[zierr &lt; 0] = np.nan

        return zi.reshape(shape), zierr.reshape(shape)


    def interpolate_nearest(self, lons, lats, data, threads=1):
        &#34;&#34;&#34;
        Interpolate using nearest-neighbour approximation
        Returns the same as `interpolate(lons,lats,data,order=0)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=0, threads=threads)

    def interpolate_linear(self, lons, lats, data, threads=1):
        &#34;&#34;&#34;
        Interpolate using linear approximation
        Returns the same as `interpolate(lons,lats,data,order=1)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=1, threads=threads)

    def interpolate_cubic(
        self,
        lons,
        lats,
        data,
        grad=None,
        sigma=None,
        *,
        threads=1,  # currently unused; provided for API consistency
    ):
        &#34;&#34;&#34;
        Interpolate using cubic spline approximation
        Returns the same as `interpolate(lons,lats,data,order=3)`
        &#34;&#34;&#34;
        return self.interpolate(
            lons,
            lats,
            data,
            order=3,
            grad=grad,
            sigma=sigma,
            threads=1,
        )


    def neighbour_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex.
        The kth neighbour is opposite to the kth vertex.
        For simplices at the boundary, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        return ltri.T[:nt,3:] - 1

    def neighbour_and_arc_simplices(self):
        &#34;&#34;&#34;
        Get indices of neighbour simplices for each simplex and arc indices.
        Identical to get_neighbour_simplices() but also returns an array
        of indices that reside on boundary hull, -1 denotes no neighbour.
        &#34;&#34;&#34;
        nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
        ltri = ltri.T[:nt] - 1
        return ltri[:,3:6], ltri[:,6:]


    def nearest_vertex(self, lons, lats):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (lons,lats)
        and return the squared great circle distance between (lons,lats) and
        each nearest neighbour.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                great circle distance (angle) on the unit sphere to the closest
                vertex identified.

        Notes:
            Faster searches can be obtained using a k-d tree.
            See `sTriangulation.nearest_vertices()` for details.
            There is an additional overhead associated with building and storing the k-d tree.

        &#34;&#34;&#34;

        # translate to unit sphere

        xi = np.array(_stripack.trans(lats, lons))
        idx = np.empty_like(xi[0,:], dtype=int)
        dist = np.empty_like(xi[0,:], dtype=float)

        for pt in range(0, xi.shape[1]):
            xi0 = xi[:,pt]

            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = ((self._x - xi0[0])**2).argmin() + 1

            idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, lons, lats):
        &#34;&#34;&#34;
        Returns indices of the triangles containing lons / lats.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            tri_indices : array of ints, shape (l,)
                indices of containing triangle


        Notes:
            The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

        &#34;&#34;&#34;
        p = self._permutation
        pts = np.array(lonlat2xyz(lons,lats)).T

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri = np.sort(t[3:6]) - 1

            triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).reshape(-1)


    def containing_simplex_and_bcc(self, lons, lats):
        &#34;&#34;&#34;
        Returns the simplices containing (lons,lats)
        and the local barycentric, normalised coordinates.

        Args:
            lons : float / array of floats, shape(l,)
                longitudinal coordinates in radians
            lats :  float / array of floats, shape(l,)
                latitudinal coordinates in radians

        Returns:
            bcc  : normalised barycentric coordinates
            tri  : simplicies containing (lons,lats)

        Notes:
            That the ordering of the vertices may differ from
            that stored in the self.simplices array but will
            still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.array(lonlat2xyz(lons,lats)).T

        tri = np.empty((pts.shape[0], 3), dtype=int) # simplices
        bcc = np.empty_like(tri, dtype=float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri[i] = t[3:6]
            bcc[i] = t[0:3]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        (from the data structures of the triangulation)
        &#34;&#34;&#34;
        vertex = self._permutation[vertex]

        lpl = self.lend[vertex-1]
        lp = lpl

        neighbours = []

        while True:
            lp = self.lptr[lp-1]
            neighbours.append(np.abs(self.lst[lp-1])-1)
            if (lp == lpl):
                break

        return self._deshuffle_simplices(neighbours)


    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))



    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        lst  = self.lst
        lend = self.lend
        lptr = self.lptr

        segments_array = np.empty((len(lptr),2),dtype=int)
        segments_array[:,0] = lst[:] - 1
        segments_array[:,1] = lst[lptr[:]-1] - 1

        valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
        segments = segments_array[valid,:]

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoint_lonlats = self.segment_midpoints(segments=segs)

        return new_midpoint_lonlats


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlons, midlats


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned. Note,
        segments in the array must not be duplicates or the re-triangulation
        will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return lons, lats

    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
        mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

        mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
        mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

        mids = np.vstack((mids1,mids2))

        midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlls


    def lons_map_to_wrapped(self, lon):

        lons = np.array(lon)
        lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

        return lons

    def tri_area(self, lons, lats):
        &#34;&#34;&#34;
        Calculate the area enclosed by 3 points on the unit sphere.

        Args:
            lons : array of floats, shape (3)
                longitudinal coordinates in radians
            lats : array of floats, shape (3)
                latitudinal coordinates in radians

        Returns:
            area : float
                area of triangle on the unit sphere

        &#34;&#34;&#34;
        lons, lats = self._check_integrity(lons, lats)

        # translate to unit sphere
        x, y, z = _stripack.trans(lats, lons)

        # compute area
        area = _stripack.areas(x, y, z)

        return area



    def areas(self):
        &#34;&#34;&#34;
        Compute the area each triangle within the triangulation of points
        on the unit sphere.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in self.simplices where nt
                is the number of triangles.

        Notes:
            This uses a Fortran 90 subroutine that wraps the AREA function
            to iterate over many points.
        &#34;&#34;&#34;

        return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;

        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        ## dot products to obtain angles
        ab = np.arccos((a * b).sum(axis=1))
        bc = np.arccos((b * c).sum(axis=1))
        ac = np.arccos((a * c).sum(axis=1))

        ## As this is a unit sphere, angle = length so ...

        return ab, bc, ac

    def angular_separation(self, lonp1, latp1, lonp2, latp2):
        &#34;&#34;&#34;
        Compute the angles between lon / lat points p1 and p2 given in radians.
        On the unit sphere, this also corresponds to the great circle distance.
        p1 and p2 can be numpy arrays of the same length.

        This method simply calls the module-level function of the same name.
        Consider using the module function instead, as this method may be
        deprecated in favor of that function. For now, this method is
        retained to avoid issues with the Jupyter notebooks.
        &#34;&#34;&#34;
        # Call the module-level function
        return angular_separation(lonp1, latp1, lonp2, latp2)

    def _add_spherical_midpoints(self):

        midlon_array, midlat_array = self.segment_midpoints()

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_spherical_tripoints(self, ratio=0.333333):

        midlon_array, midlat_array = self.segment_tripoints(ratio=ratio)

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_face_centroids(self):

        facelon_array, facelat_array = self.face_midpoints()

        lonv2 = np.concatenate((self.lons, facelon_array), axis=0)
        latv2 = np.concatenate((self.lats, facelat_array), axis=0)

        return lonv2, latv2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            lonv1, latv1 = self._add_face_centroids()

        else:
            if not trisect:
                lonv1, latv1 = self._add_spherical_midpoints()
            else:
                lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


        return lonv1, latv1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1




    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i].`
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        mlons, mlats = self.segment_midpoints(segs)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)



    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by adding the
        face centroids of the triangles in the list of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by adding the
        face centroids in the triangulation connected to any of the vertices in
        the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)



    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=True to skip the testing and duplicate removal
        &#34;&#34;&#34;

        lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
        latv1 = np.concatenate((self.lats, t2.lats), axis=0)

        ## remove any duplicates

        if not unique:
            lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

        return lonv1, latv1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree =  scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            lon : 1D array
                longitudinal coordinates in radians
            lat : 1D array
                latitudinal coordinates in radians
            k : int (default: 1)
                number of nearest neighbours to return
            max_distance : float (default: 2.0)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        lons = np.array(lon).reshape(-1,1)
        lats = np.array(lat).reshape(-1,1)

        xyz = np.empty((lons.shape[0],3))
        x,y,z = lonlat2xyz(lons, lats)

        xyz[:,0] = x[:].reshape(-1)
        xyz[:,1] = y[:].reshape(-1)
        xyz[:,2] = z[:].reshape(-1)

        dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        ## Now find the angular separation / great circle distance: dlatlon


        vertxyz = self.points[vertices].transpose(0,2,1)
        extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

        angles = np.arccos((extxyz * vertxyz).sum(axis=1))

        return angles, vertices


    def voronoi_points(self, return_circumradius=False):
        &#34;&#34;&#34;
        Calculates the voronoi points from the triangulation.

        This routine returns the circumcentre, circumradius of each triangle.

        Args:
            return_circumradius : bool
                optionally return circumradius of each circumcentre

        Returns:
            vlons : ndarray of floats
                longitudinal coordinates of the Voronoi
            vlats : ndarray of floats
                latitudinal coordinates of the Voronoi
            cr : ndarray of floats (optional)
                coordinates of the circumcentre (centre of the circle
                defined by three points in a triangle)
        &#34;&#34;&#34;

        # get x,y,z coordinates for each triangle
        simplices = self.simplices
        xt = self.x[simplices]
        yt = self.y[simplices]
        zt = self.z[simplices]

        # construct 3-component vectors
        v1 = np.column_stack([xt[:,0], yt[:,0], zt[:,0]])
        v2 = np.column_stack([xt[:,1], yt[:,1], zt[:,1]])
        v3 = np.column_stack([xt[:,2], yt[:,2], zt[:,2]])

        # get edge lengths
        e1 = v2 - v1
        e2 = v3 - v1

        # compute scalar multiples of e1 * e2
        cu = np.empty_like(xt)
        cu[:,0] = e1[:,1]*e2[:,2] - e1[:,2]*e2[:,1]
        cu[:,1] = e1[:,2]*e2[:,0] - e1[:,0]*e2[:,2]
        cu[:,2] = e1[:,0]*e2[:,1] - e1[:,1]*e2[:,0]

        # compute normal vector
        cnorm = np.sqrt( (cu**2).sum(axis=1) )

        coords = cu / cnorm.reshape(-1,1)
        xc, yc, zc = coords[:,0], coords[:,1], coords[:,2]

        # convert to lon/lat
        vlons, vlats = xyz2lonlat(xc,yc,zc)

        out = [vlons, vlats]

        if return_circumradius:
            tr = (v1*coords).sum(axis=1)
            tr = np.clip(tr, -1.0, 1.0)
            cr = np.arccos(tr)
            out.append( cr )

        return tuple(out)

    def voronoi_points_and_regions(self):
        &#34;&#34;&#34;
        Calculates the voronoi points from the triangulation
        and constructs the region enclosed by them.

        Returns:
            vlons : ndarray of floats
                longitudinal coordinates of the Voronoi
            vlats : ndarray of floats
                latitudinal coordinates of the Voronoi
            regions : list of ints
                a nested list of all Voronoi indices that
                enclose a region.

        Notes:
            Inifinite regions are not indicated.
        &#34;&#34;&#34;

        vx, vy = self.voronoi_points()

        # store these to avoid any shuffle/reshuffle later
        simplices = self.simplices
        x = self.lons
        y = self.lats

        # empty placeholder array for vertices
        voronoi_regions = [[] for i in range(0, self.npoints)]

        # create regions for each point in the Delaunay triangulation
        for i, (t0,t1,t2) in enumerate(simplices):
            voronoi_regions[t0].append(i)
            voronoi_regions[t1].append(i)
            voronoi_regions[t2].append(i)

        # sort the vertices around each site
        # there is probably a more efficient way using the neighbour adjacency info
        for i in range(0, self.npoints):
            region = np.array(voronoi_regions[i])
            dx = vx[region] - x[i]
            dy = vy[region] - y[i]
            idx = np.arctan2(dx, dy).argsort() # this could be a problem across the dateline
            voronoi_regions[i] = region[idx]

        return vx, vy, voronoi_regions</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stripy.spherical_meshes.icosahedral_mesh" href="spherical_meshes.html#stripy.spherical_meshes.icosahedral_mesh">icosahedral_mesh</a></li>
<li><a title="stripy.spherical_meshes.octahedral_mesh" href="spherical_meshes.html#stripy.spherical_meshes.octahedral_mesh">octahedral_mesh</a></li>
<li><a title="stripy.spherical_meshes.random_mesh" href="spherical_meshes.html#stripy.spherical_meshes.random_mesh">random_mesh</a></li>
<li><a title="stripy.spherical_meshes.triangulated_cube_mesh" href="spherical_meshes.html#stripy.spherical_meshes.triangulated_cube_mesh">triangulated_cube_mesh</a></li>
<li><a title="stripy.spherical_meshes.triangulated_soccerball_mesh" href="spherical_meshes.html#stripy.spherical_meshes.triangulated_soccerball_mesh">triangulated_soccerball_mesh</a></li>
<li><a title="stripy.spherical_meshes.uniform_ring_mesh" href="spherical_meshes.html#stripy.spherical_meshes.uniform_ring_mesh">uniform_ring_mesh</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="stripy.spherical.sTriangulation.lats"><code class="name">var <span class="ident">lats</span></code></dt>
<dd>
<div class="desc"><p>Latitudinal coordinates on a sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lats(self):
    &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
    return self._deshuffle_field(self._lats)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.lons"><code class="name">var <span class="ident">lons</span></code></dt>
<dd>
<div class="desc"><p>Longitudinal coordinates on a sphere</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lons(self):
    &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
    return self._deshuffle_field(self._lons)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.points"><code class="name">var <span class="ident">points</span></code></dt>
<dd>
<div class="desc"><p>Stored Cartesian xyz coordinates from triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._points)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.simplices"><code class="name">var <span class="ident">simplices</span></code></dt>
<dd>
<div class="desc"><p>Indices of the points forming the simplices in the triangulation.
Points are ordered anticlockwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simplices(self):
    &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
    Points are ordered anticlockwise &#34;&#34;&#34;
    return self._deshuffle_simplices(self._simplices)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"><p>Stored Cartesian x coordinates from triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._x)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"><p>Stored Cartesian y coordinates from triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._y)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<div class="desc"><p>Stored Cartesian x coordinates from triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._z)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stripy.spherical.sTriangulation.angular_separation"><code class="name flex">
<span>def <span class="ident">angular_separation</span></span>(<span>self, lonp1, latp1, lonp2, latp2)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the angles between lon / lat points p1 and p2 given in radians.
On the unit sphere, this also corresponds to the great circle distance.
p1 and p2 can be numpy arrays of the same length.</p>
<p>This method simply calls the module-level function of the same name.
Consider using the module function instead, as this method may be
deprecated in favor of that function. For now, this method is
retained to avoid issues with the Jupyter notebooks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_separation(self, lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.

    This method simply calls the module-level function of the same name.
    Consider using the module function instead, as this method may be
    deprecated in favor of that function. For now, this method is
    retained to avoid issues with the Jupyter notebooks.
    &#34;&#34;&#34;
    # Call the module-level function
    return angular_separation(lonp1, latp1, lonp2, latp2)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.areas"><code class="name flex">
<span>def <span class="ident">areas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the area each triangle within the triangulation of points
on the unit sphere.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>area </code></dt>
<dd>array of floats, shape (nt,)
area of each triangle in self.simplices where nt
is the number of triangles.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This uses a Fortran 90 subroutine that wraps the AREA function
to iterate over many points.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def areas(self):
    &#34;&#34;&#34;
    Compute the area each triangle within the triangulation of points
    on the unit sphere.

    Returns:
        area : array of floats, shape (nt,)
            area of each triangle in self.simplices where nt
            is the number of triangles.

    Notes:
        This uses a Fortran 90 subroutine that wraps the AREA function
        to iterate over many points.
    &#34;&#34;&#34;

    return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by adding the
face centroids of the triangles in the list of indices provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i]</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroid_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by adding the
    face centroids of the triangles in the list of indices provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i]`.
    &#34;&#34;&#34;

    # Remove duplicates from the list of triangles

    triangles = np.unique(np.array(triangles))

    mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by adding the
face centroids in the triangulation connected to any of the vertices in
the list provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroid_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by adding the
    face centroids in the triangulation connected to any of the vertices in
    the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.centroid_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.containing_simplex_and_bcc"><code class="name flex">
<span>def <span class="ident">containing_simplex_and_bcc</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the simplices containing (lons,lats)
and the local barycentric, normalised coordinates.</p>
<h2 id="args">Args</h2>
<p>lons : float / array of floats, shape(l,)
longitudinal coordinates in radians
lats :
float / array of floats, shape(l,)
latitudinal coordinates in radians</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bcc
</code></dt>
<dd>normalised barycentric coordinates</dd>
<dt><code>tri
</code></dt>
<dd>simplicies containing (lons,lats)</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>That the ordering of the vertices may differ from
that stored in the self.simplices array but will
still be a loop around the simplex.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containing_simplex_and_bcc(self, lons, lats):
    &#34;&#34;&#34;
    Returns the simplices containing (lons,lats)
    and the local barycentric, normalised coordinates.

    Args:
        lons : float / array of floats, shape(l,)
            longitudinal coordinates in radians
        lats :  float / array of floats, shape(l,)
            latitudinal coordinates in radians

    Returns:
        bcc  : normalised barycentric coordinates
        tri  : simplicies containing (lons,lats)

    Notes:
        That the ordering of the vertices may differ from
        that stored in the self.simplices array but will
        still be a loop around the simplex.
    &#34;&#34;&#34;

    pts = np.array(lonlat2xyz(lons,lats)).T

    tri = np.empty((pts.shape[0], 3), dtype=int) # simplices
    bcc = np.empty_like(tri, dtype=float) # barycentric coords

    for i, pt in enumerate(pts):
        t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
        tri[i] = t[3:6]
        bcc[i] = t[0:3]

    tri -= 1 # return to C ordering

    bcc /= bcc.sum(axis=1).reshape(-1,1)

    return bcc, self._deshuffle_simplices(tri)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.containing_triangle"><code class="name flex">
<span>def <span class="ident">containing_triangle</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns indices of the triangles containing lons / lats.</p>
<h2 id="args">Args</h2>
<p>lons : float / array of floats, shape (l,)
longitudinal coordinate(s) on the sphere
lats : float / array of floats, shape (l,)
latitudinal coordinate(s) on the sphere</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tri_indices </code></dt>
<dd>array of ints, shape (l,)
indices of containing triangle</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The simplices are found as <code>spherical.sTriangulation.simplices[tri_indices]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containing_triangle(self, lons, lats):
    &#34;&#34;&#34;
    Returns indices of the triangles containing lons / lats.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere

    Returns:
        tri_indices : array of ints, shape (l,)
            indices of containing triangle


    Notes:
        The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

    &#34;&#34;&#34;
    p = self._permutation
    pts = np.array(lonlat2xyz(lons,lats)).T

    sorted_simplices = np.sort(self._simplices, axis=1)

    triangles = []
    for pt in pts:
        t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
        tri = np.sort(t[3:6]) - 1

        triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

    return np.array(triangles).reshape(-1)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.derivatives_lonlat"><code class="name flex">
<span>def <span class="ident">derivatives_lonlat</span></span>(<span>self, data, nit=3, tol=0.001, guarantee_convergence=False, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the lon / lat components of the derivatives
of a scalar field on the surface of the UNIT sphere.
(Note: the companion routine is gradient_lonlat which returns
the components of the surface gradient - these differ by a factor of
1/cos(lat) in the first component)</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors, where Q is an approximation to the linearized
curvature over the triangulation of a C-1 bivariate function F(x,y)
which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<p>data : array of floats, shape (n,)
field over which to evaluate the gradient
nit : int (default: 3)
number of iterations to reach a convergence tolerance, tol
nit &gt;= 1
tol : float (default: 1e-3)
maximum change in gradient between iterations.
convergence is reached when this condition is met.
sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dfdlon </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the longitudinal direction</dd>
<dt><code>dfdlat </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the lattitudinal direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The gradient is computed via the Cartesian components using
<code>spherical.sTriangulation.gradient_xyz</code> and the iteration parameters
controling the spline interpolation are passed directly to this
routine (See notes for <code>gradient_xyz</code> for more details).</p>
<p>The gradient operator in this geometry is not well defined at the poles
even if the scalar field is smooth and the Cartesian gradient is well defined.</p>
<p>The routine spherical.dxyz2dlonlat is available to convert the Cartesian
to lon/lat coordinates at any point on the unit sphere. This is helpful
to avoid recalculation if you need both forms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def derivatives_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
    &#34;&#34;&#34;
    Return the lon / lat components of the derivatives
    of a scalar field on the surface of the UNIT sphere.
    (Note: the companion routine is gradient_lonlat which returns
    the components of the surface gradient - these differ by a factor of 
    1/cos(lat) in the first component)


    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors, where Q is an approximation to the linearized
    curvature over the triangulation of a C-1 bivariate function F(x,y)
    which interpolates the nodal values and gradients.

    Args:
        data : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance, tol
            nit &gt;= 1
        tol : float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.
        sigma : array of floats, shape (6n-12)
            precomputed array of spline tension factors from
            `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

    Returns:
        dfdlon : array of floats, shape (n,)
            derivative of f in the longitudinal direction
        dfdlat : array of floats, shape (n,)
            derivative of f in the lattitudinal direction

    Notes:
        The gradient is computed via the Cartesian components using
        `spherical.sTriangulation.gradient_xyz` and the iteration parameters
        controling the spline interpolation are passed directly to this
        routine (See notes for `gradient_xyz` for more details).

        The gradient operator in this geometry is not well defined at the poles
        even if the scalar field is smooth and the Cartesian gradient is well defined.

        The routine spherical.dxyz2dlonlat is available to convert the Cartesian
        to lon/lat coordinates at any point on the unit sphere. This is helpful
        to avoid recalculation if you need both forms.
    &#34;&#34;&#34;

    dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
        guarantee_convergence=guarantee_convergence, sigma=sigma)

    # get deshuffled versions
    lons = self.lons
    lats = self.lats
    z = self.z

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    return dlon, dlat</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_lengths"><code class="name flex">
<span>def <span class="ident">edge_lengths</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the edge-lengths of each triangle in the triangulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_lengths(self):
    &#34;&#34;&#34;
    Compute the edge-lengths of each triangle in the triangulation.
    &#34;&#34;&#34;

    simplex = self.simplices.T

    # simplex is vectors a, b, c defining the corners
    a = self.points[simplex[0]]
    b = self.points[simplex[1]]
    c = self.points[simplex[2]]

    ## dot products to obtain angles
    ab = np.arccos((a * b).sum(axis=1))
    bc = np.arccos((b * c).sum(axis=1))
    ac = np.arccos((a * c).sum(axis=1))

    ## As this is a unit sphere, angle = length so ...

    return ab, bc, ac</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation that are associated with the triangles in the list
of indices provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i].</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation that are associated with the triangles in the list
    of indices provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i].`
    &#34;&#34;&#34;

    ## Note there should be no duplicates in the list of triangles
    ## but because we remove duplicates from the list of all segments,
    ## there is no pressing need to check this.

    # identify the segments

    simplices = self.simplices
    segments = set()

    for index in np.array(triangles).reshape(-1):
        tri = simplices[index]
        segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
        segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
        segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

    segs = np.array(list(segments))

    mlons, mlats = self.segment_midpoints(segs)

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.edge_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.face_midpoints"><code class="name flex">
<span>def <span class="ident">face_midpoints</span></span>(<span>self, simplices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify the centroid of every simplex in the triangulation. If an array of
simplices is given then the centroids of only those simplices is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_midpoints(self, simplices=None):
    &#34;&#34;&#34;
    Identify the centroid of every simplex in the triangulation. If an array of
    simplices is given then the centroids of only those simplices is returned.
    &#34;&#34;&#34;

    if type(simplices) == type(None):
        simplices = self.simplices

    mids = self.points[simplices].mean(axis=1)
    mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

    midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return midlons, midlats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.get_spline_tension_factors"><code class="name flex">
<span>def <span class="ident">get_spline_tension_factors</span></span>(<span>self, zdata, tol=0.001, grad=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines, for each triangulation arc, the smallest (nonnegative) tension factor <code>sigma</code>
such that the Hermite interpolatory tension spline, defined by <code>sigma</code> and specified
endpoint data, preserves local shape properties (monotonicity and convexity) of <code>zdata</code>.</p>
<h2 id="args">Args</h2>
<p>zdata : array of floats, shape(n,)
value at each point in the triangulation
must be the same size of the mesh
tol : float
tolerance of each tension factor to its optimal value
when nonzero finite tension is necessary.
grad : array of floats, shape(3,n)
precomputed gradient of zdata or if not provided,
the result of <code>self.gradient(zdata)</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>sigma </code></dt>
<dd>
<p>array of floats, shape(6n-12)
tension factors which preserves the local properties of <code>zdata</code> on each
triangulation arc with the restriction that <code>sigma[i] &lt;= 85</code>.</p>
<ul>
<li><code>sigma[i] = 85</code> if infinite tension is required on an arc.</li>
<li><code>sigma[i] = 0</code> if the result should be cubic on the arc.</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Supply sigma to gradient, interpolate, derivative, or smoothing
methods for tensioned splines. Here is a list of compatible methods:</p>
<ul>
<li><code>interpolate(lons, lats, zdata, order=3, grad=None, sigma=None)</code></li>
<li><code>interpolate_cubic(lons, lats, zdata, grad=None, sigma=None)</code></li>
<li><code>interpolate_to_grid(lons, lats, zdata, grad=None, sigma=None)</code></li>
<li><code>gradient_xyz(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)</code></li>
<li><code>gradient_lonlat(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)</code></li>
<li><code>smoothing(f, w, sm, smtol, gstol, sigma=None)</code></li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_spline_tension_factors(self, zdata, tol=1e-3, grad=None):
    &#34;&#34;&#34;
    Determines, for each triangulation arc, the smallest (nonnegative) tension factor `sigma`
    such that the Hermite interpolatory tension spline, defined by `sigma` and specified
    endpoint data, preserves local shape properties (monotonicity and convexity) of `zdata`.

    Args:
        zdata : array of floats, shape(n,)
            value at each point in the triangulation
            must be the same size of the mesh
        tol : float
            tolerance of each tension factor to its optimal value
            when nonzero finite tension is necessary.
        grad : array of floats, shape(3,n)
            precomputed gradient of zdata or if not provided,
            the result of `self.gradient(zdata)`.

    Returns:
        sigma : array of floats, shape(6n-12)
            tension factors which preserves the local properties of `zdata` on each
            triangulation arc with the restriction that `sigma[i] &lt;= 85`.

            - `sigma[i] = 85` if infinite tension is required on an arc.
            - `sigma[i] = 0` if the result should be cubic on the arc.

    Notes:
        Supply sigma to gradient, interpolate, derivative, or smoothing
        methods for tensioned splines. Here is a list of compatible methods:

        - `interpolate(lons, lats, zdata, order=3, grad=None, sigma=None)`
        - `interpolate_cubic(lons, lats, zdata, grad=None, sigma=None)`
        - `interpolate_to_grid(lons, lats, zdata, grad=None, sigma=None)`
        - `gradient_xyz(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
        - `gradient_lonlat(f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None)`
        - `smoothing(f, w, sm, smtol, gstol, sigma=None)`

    &#34;&#34;&#34;

    if zdata.size != self.npoints:
        raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

    p = self._permutation
    zdata = self._shuffle_field(zdata)

    if grad is None:
        grad = np.vstack(self.gradient_xyz(zdata, tol=tol))
        grad = grad[:,p] # permute

    elif grad.shape == (3,self.npoints):
        grad = grad[:,p] # permute

    else:
        raise ValueError(&#34;gradient should be &#39;None&#39; or of shape (3,n).&#34;)

    sigma, dsmax, ierr = _ssrfpack.getsig(self._x, self._y, self._z, zdata,\
                                          self.lst, self.lptr, self.lend,\
                                          grad, tol)

    if ierr == -1:
        import warnings
        warnings.warn(&#34;sigma is not altered.&#34;)

    # self.sigma = sigma
    # self.iflgs = int(sigma.any())

    return sigma</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.gradient_lonlat"><code class="name flex">
<span>def <span class="ident">gradient_lonlat</span></span>(<span>self, data, nit=3, tol=0.001, guarantee_convergence=False, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the lon / lat components of the gradient
of a scalar field on the surface of the UNIT sphere.
(Note: the companion routine is derivatives_lonlat which returns
the components of the derivative in each direction - these differ by a factor of
1/cos(lat) in the first component)</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors, where Q is an approximation to the linearized
curvature over the triangulation of a C-1 bivariate function F(x,y)
which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<p>data : array of floats, shape (n,)
field over which to evaluate the gradient
nit : int (default: 3)
number of iterations to reach a convergence tolerance, tol
nit &gt;= 1
tol : float (default: 1e-3)
maximum change in gradient between iterations.
convergence is reached when this condition is met.
sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dfdlon </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the longitudinal direction</dd>
<dt><code>dfdlat </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the lattitudinal direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The gradient is computed via the Cartesian components using
<code>spherical.sTriangulation.gradient_xyz</code> and the iteration parameters
controling the spline interpolation are passed directly to this
routine (See notes for <code>gradient_xyz</code> for more details).</p>
<p>The gradient operator in this geometry is not well defined at the poles
even if the scalar field is smooth and the Cartesian gradient is well defined.</p>
<p>The routine spherical.dxyz2dlonlat is available to convert the Cartesian
to lon/lat coordinates at any point on the unit sphere. This is helpful
to avoid recalculation if you need both forms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False, sigma=None):
    &#34;&#34;&#34;
    Return the lon / lat components of the gradient
    of a scalar field on the surface of the UNIT sphere.
    (Note: the companion routine is derivatives_lonlat which returns
    the components of the derivative in each direction - these differ by a factor of 
    1/cos(lat) in the first component)

    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors, where Q is an approximation to the linearized
    curvature over the triangulation of a C-1 bivariate function F(x,y)
    which interpolates the nodal values and gradients.

    Args:
        data : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance, tol
            nit &gt;= 1
        tol : float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.
        sigma : array of floats, shape (6n-12)
            precomputed array of spline tension factors from
            `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

    Returns:
        dfdlon : array of floats, shape (n,)
            derivative of f in the longitudinal direction
        dfdlat : array of floats, shape (n,)
            derivative of f in the lattitudinal direction

    Notes:
        The gradient is computed via the Cartesian components using
        `spherical.sTriangulation.gradient_xyz` and the iteration parameters
        controling the spline interpolation are passed directly to this
        routine (See notes for `gradient_xyz` for more details).

        The gradient operator in this geometry is not well defined at the poles
        even if the scalar field is smooth and the Cartesian gradient is well defined.

        The routine spherical.dxyz2dlonlat is available to convert the Cartesian
        to lon/lat coordinates at any point on the unit sphere. This is helpful
        to avoid recalculation if you need both forms.
    &#34;&#34;&#34;

    dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, \
        guarantee_convergence=guarantee_convergence, sigma=sigma)

    # get deshuffled versions
    lons = self.lons
    lats = self.lats
    z = self.z

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-z**2))  
    valid = ~np.isclose(corr,0.0)
    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.gradient_xyz"><code class="name flex">
<span>def <span class="ident">gradient_xyz</span></span>(<span>self, f, nit=3, tol=0.001, guarantee_convergence=False, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the cartesian components of the gradient
of a scalar field on the surface of the sphere.</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors, where Q is an approximation to the linearized
curvature over the triangulation of a C-1 bivariate function F(x,y)
which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<p>f : array of floats, shape (n,)
field over which to evaluate the gradient
nit : int (default: 3)
number of iterations to reach a convergence tolerance, tol
nit &gt;= 1
tol : float (default: 1e-3)
maximum change in gradient between iterations.
convergence is reached when this condition is met.
sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dfdx </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the x direction</dd>
<dt><code>dfdy </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the y direction</dd>
<dt><code>dfdz </code></dt>
<dd>array of floats, shape (n,)
derivative of f in the z direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For SIGMA = 0, optimal efficiency was achieved in testing with
tol = 0, and nit = 3 or 4.</p>
<p>The restriction of F to an arc of the triangulation is taken to be
the Hermite interpolatory tension spline defined by the data values
and tangential gradient components at the endpoints of the arc, and
Q is the sum over the triangulation arcs, excluding interior
constraint arcs, of the linearized curvatures of F along the arcs &ndash;
the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
derivative of F with respect to distance T along the arc.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False, sigma=None):
    &#34;&#34;&#34;
    Return the cartesian components of the gradient
    of a scalar field on the surface of the sphere.

    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors, where Q is an approximation to the linearized
    curvature over the triangulation of a C-1 bivariate function F(x,y)
    which interpolates the nodal values and gradients.

    Args:
        f : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance, tol
            nit &gt;= 1
        tol : float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.
        sigma : array of floats, shape (6n-12)
            precomputed array of spline tension factors from
            `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

    Returns:
        dfdx : array of floats, shape (n,)
            derivative of f in the x direction
        dfdy : array of floats, shape (n,)
            derivative of f in the y direction
        dfdz : array of floats, shape (n,)
            derivative of f in the z direction

    Notes:
        For SIGMA = 0, optimal efficiency was achieved in testing with
        tol = 0, and nit = 3 or 4.

        The restriction of F to an arc of the triangulation is taken to be
        the Hermite interpolatory tension spline defined by the data values
        and tangential gradient components at the endpoints of the arc, and
        Q is the sum over the triangulation arcs, excluding interior
        constraint arcs, of the linearized curvatures of F along the arcs --
        the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
        derivative of F with respect to distance T along the arc.
    &#34;&#34;&#34;

    if f.size != self.npoints:
        raise ValueError(&#39;f should be the same size as mesh&#39;)

    # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=float32)
    sigma, iflgs = self._check_sigma(sigma)

    f = self._shuffle_field(f)

    ierr = 1
    while ierr == 1:
        grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f,\
                                     self.lst, self.lptr, self.lend,\
                                     iflgs, sigma, nit, tol)
        if not guarantee_convergence:
            break

    import warnings

    if ierr &lt; 0:
        import warnings
        warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

    return self._deshuffle_field(grad[0], grad[1], grad[2])</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_segments"><code class="name flex">
<span>def <span class="ident">identify_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Find all the segments in the triangulation and return an
array of vertices (n1,n2) where n1 &lt; n2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_segments(self):
    &#34;&#34;&#34;
    Find all the segments in the triangulation and return an
    array of vertices (n1,n2) where n1 &lt; n2
    &#34;&#34;&#34;

    lst  = self.lst
    lend = self.lend
    lptr = self.lptr

    segments_array = np.empty((len(lptr),2),dtype=int)
    segments_array[:,0] = lst[:] - 1
    segments_array[:,1] = lst[lptr[:]-1] - 1

    valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
    segments = segments_array[valid,:]

    return self._deshuffle_simplices(segments)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_vertex_neighbours"><code class="name flex">
<span>def <span class="ident">identify_vertex_neighbours</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the neighbour-vertices in the triangulation for the given vertex
(from the data structures of the triangulation)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_vertex_neighbours(self, vertex):
    &#34;&#34;&#34;
    Find the neighbour-vertices in the triangulation for the given vertex
    (from the data structures of the triangulation)
    &#34;&#34;&#34;
    vertex = self._permutation[vertex]

    lpl = self.lend[vertex-1]
    lp = lpl

    neighbours = []

    while True:
        lp = self.lptr[lp-1]
        neighbours.append(np.abs(self.lst[lp-1])-1)
        if (lp == lpl):
            break

    return self._deshuffle_simplices(neighbours)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_vertex_triangles"><code class="name flex">
<span>def <span class="ident">identify_vertex_triangles</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>Find all triangles which own any of the vertices in the list provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_vertex_triangles(self, vertices):
    &#34;&#34;&#34;
    Find all triangles which own any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = []

    for vertex in np.array(vertices).reshape(-1):
        triangles.append(np.where(self.simplices == vertex)[0])

    return np.unique(np.concatenate(triangles))</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, lons, lats, zdata, order=1, grad=None, sigma=None, threads=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class to handle nearest neighbour, linear, and cubic interpolation.
Given a triangulation of a set of nodes on the unit sphere, along with data
values at the nodes, this method interpolates (or extrapolates) the value
at a given longitude and latitude.</p>
<h2 id="args">Args</h2>
<p>lons : float / array of floats, shape (l,)
longitudinal coordinate(s) on the sphere
lats : float / array of floats, shape (l,)
latitudinal coordinate(s) on the sphere
zdata : array of floats, shape (n,)
value at each point in the triangulation
must be the same size of the mesh
order : int (default=1)
order of the interpolatory function used</p>
<pre><code>- `order=0` = nearest-neighbour
- `order=1` = linear
- `order=3` = cubic
</code></pre>
<p>sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code>
(only used in cubic interpolation)</p>
<p>threads : int or 'auto', optional; default : 1
Number of threads to use for linear and nearest-neighbour
interpolation (N.B. multi-threaded cubic interpolation is
not supported).
By default, only a single thread will be used. Use
<code>threads='auto'</code> to attempt to automatically determine how
many threads to use based on the size of the input and output
data.
Negative values count backwards, such that -1 is equivalent to
<code>multiprocessing.cpu_count()</code>, -2 to <code>cpu_count() - 1</code>, etc.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>zi </code></dt>
<dd>float / array of floats, shape (l,)
interpolated value(s) at (lons, lats)</dd>
<dt><code>err </code></dt>
<dd>int / array of ints, shape (l,)
whether interpolation (0), extrapolation (1) or error (other)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(
    self,
    lons,
    lats,
    zdata,
    order=1,
    grad=None,
    sigma=None,
    threads=1,
):
    &#34;&#34;&#34;
    Base class to handle nearest neighbour, linear, and cubic interpolation.
    Given a triangulation of a set of nodes on the unit sphere, along with data
    values at the nodes, this method interpolates (or extrapolates) the value
    at a given longitude and latitude.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere
        zdata : array of floats, shape (n,)
            value at each point in the triangulation
            must be the same size of the mesh
        order : int (default=1)
            order of the interpolatory function used

            - `order=0` = nearest-neighbour
            - `order=1` = linear
            - `order=3` = cubic

        sigma : array of floats, shape (6n-12)
            precomputed array of spline tension factors from
            `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`
            (only used in cubic interpolation)

        threads : int or &#39;auto&#39;, optional; default : 1
            Number of threads to use for linear and nearest-neighbour
            interpolation (N.B. multi-threaded cubic interpolation is
            not supported).
            By default, only a single thread will be used. Use
            `threads=&#39;auto&#39;` to attempt to automatically determine how
            many threads to use based on the size of the input and output
            data.
            Negative values count backwards, such that -1 is equivalent to
            `multiprocessing.cpu_count()`, -2 to `cpu_count() - 1`, etc.

    Returns:
        zi : float / array of floats, shape (l,)
            interpolated value(s) at (lons, lats)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
    &#34;&#34;&#34;
    shape = np.shape(lons)

    lons, lats = self._check_integrity(lons, lats)
    n_in = np.size(zdata)
    n_out = np.size(lons)

    if n_in != self.npoints:
        raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

    zdata = self._shuffle_field(zdata)

    if order not in {0, 1, 3}:
        raise ValueError(&#34;order must be 0, 1, or 3&#34;)
    if threads == 0:
        raise ValueError(&#34;threads must not be zero&#34;)

    if threads == &#34;auto&#34;:
        # Try to guess whether multiple threads would be helpful
        threads = _auto_threads(n_in, n_out, order)
    threads = int(threads)

    if order == 3 and threads != 1:
        import warnings

        warnings.warn(
            &#34;Multithreading not supported for cubic interpolation&#34;,
            RuntimeWarning,
        )
        threads = 1

    if threads &lt; 0:
        # -1 corresponds to cpu_count(), etc.
        threads = cpu_count() + threads + 1

    if threads == 1:
        if order == 3:
            sigma, iflgs = self._check_sigma(sigma)
            grad, iflgg = self._check_gradient(zdata, grad)

            zi, zierr, ierr = _ssrfpack.interp_cubic(lats, lons,
                                        self._x, self._y, self._z, zdata,
                                        self.lst, self.lptr, self.lend,
                                        iflgs, sigma, iflgg, grad)
        else:
            zi, zierr, ierr = _stripack.interp_n(order, lats, lons,
                                        self._x, self._y, self._z, zdata,
                                        self.lst, self.lptr, self.lend)

    else:
        # The following code is largely adapted from here:
        # https://numpy.org/doc/stable/reference/random/multithreading.html
        import concurrent.futures

        size = lons.size
        zi = np.full(size, np.nan)
        zierr = np.full(size, np.nan)
        ierr = np.full(threads, 0)
        step = np.ceil(size / threads).astype(np.int_)
        futures = {}
        executor = concurrent.futures.ThreadPoolExecutor(threads)

        def _f(
            out_zi,
            out_zierr,
            out_ierr,
            order,
            lats,
            lons,
            x,
            y,
            z,
            zdata,
            lst,
            lptr,
            lend,
            first,
            last,
            ierr_index,
        ):
            tmp_zi, tmp_zierr, tmp_ierr = _stripack.interp_n(
                order, lats[first:last], lons[first:last],
                x, y, z, zdata,
                lst, lptr, lend,
            )
            out_zi[first:last] = tmp_zi
            out_zierr[first:last] = tmp_zierr
            out_ierr[ierr_index] = tmp_ierr

        for i in range(threads):
            first = i * step
            last = (i + 1) * step
            args = (
                _f,
                zi,
                zierr,
                ierr,
                order,
                lats,
                lons,
                self._x,
                self._y,
                self._z,
                zdata,
                self.lst,
                self.lptr,
                self.lend,
                first,
                last,
                i,
            )
            futures[executor.submit(*args)] = i
        concurrent.futures.wait(futures)
        executor.shutdown(False)
        ierr = int((ierr != 0).any())

    if ierr != 0:
        import warnings
        warnings.warn(
            &#39;Warning some points may have errors - check error array&#39;,
            RuntimeWarning,
        )
        zi[zierr &lt; 0] = np.nan

    return zi.reshape(shape), zierr.reshape(shape)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_cubic"><code class="name flex">
<span>def <span class="ident">interpolate_cubic</span></span>(<span>self, lons, lats, data, grad=None, sigma=None, *, threads=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate using cubic spline approximation
Returns the same as <code>interpolate(lons,lats,data,order=3)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_cubic(
    self,
    lons,
    lats,
    data,
    grad=None,
    sigma=None,
    *,
    threads=1,  # currently unused; provided for API consistency
):
    &#34;&#34;&#34;
    Interpolate using cubic spline approximation
    Returns the same as `interpolate(lons,lats,data,order=3)`
    &#34;&#34;&#34;
    return self.interpolate(
        lons,
        lats,
        data,
        order=3,
        grad=grad,
        sigma=sigma,
        threads=1,
    )</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_linear"><code class="name flex">
<span>def <span class="ident">interpolate_linear</span></span>(<span>self, lons, lats, data, threads=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate using linear approximation
Returns the same as <code>interpolate(lons,lats,data,order=1)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_linear(self, lons, lats, data, threads=1):
    &#34;&#34;&#34;
    Interpolate using linear approximation
    Returns the same as `interpolate(lons,lats,data,order=1)`
    &#34;&#34;&#34;
    return self.interpolate(lons, lats, data, order=1, threads=threads)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_nearest"><code class="name flex">
<span>def <span class="ident">interpolate_nearest</span></span>(<span>self, lons, lats, data, threads=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Interpolate using nearest-neighbour approximation
Returns the same as <code>interpolate(lons,lats,data,order=0)</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_nearest(self, lons, lats, data, threads=1):
    &#34;&#34;&#34;
    Interpolate using nearest-neighbour approximation
    Returns the same as `interpolate(lons,lats,data,order=0)`
    &#34;&#34;&#34;
    return self.interpolate(lons, lats, data, order=0, threads=threads)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_to_grid"><code class="name flex">
<span>def <span class="ident">interpolate_to_grid</span></span>(<span>self, lons, lats, zdata, grad=None, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Interplates the data values to a uniform grid defined by
longitude and latitudinal arrays. The interpolant is once
continuously differentiable. Extrapolation is performed at
grid points exterior to the triangulation when the nodes
do not cover the entire sphere.</p>
<h2 id="args">Args</h2>
<p>lons : array of floats, shape (ni,)
longitudinal coordinates in ascending order
lats : array of floats, shape (nj,)
latitudinal coordinates in ascending order
zdata : array of floats, shape(n,)
value at each point in the triangulation
must be the same size of the mesh
grad : array of floats, shape(3,n)
precomputed gradient of zdata or if not provided,
the result of <code>self.gradient(zdata)</code>.
sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>zgrid </code></dt>
<dd>array of floats, shape(nj,ni)
interpolated values defined by gridded lons/lats</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_to_grid(self, lons, lats, zdata, grad=None, sigma=None):
    &#34;&#34;&#34;
    Interplates the data values to a uniform grid defined by
    longitude and latitudinal arrays. The interpolant is once
    continuously differentiable. Extrapolation is performed at
    grid points exterior to the triangulation when the nodes
    do not cover the entire sphere.

    Args:
        lons : array of floats, shape (ni,)
            longitudinal coordinates in ascending order
        lats : array of floats, shape (nj,)
            latitudinal coordinates in ascending order
        zdata : array of floats, shape(n,)
            value at each point in the triangulation
            must be the same size of the mesh
        grad : array of floats, shape(3,n)
            precomputed gradient of zdata or if not provided,
            the result of `self.gradient(zdata)`.
        sigma : array of floats, shape (6n-12)
            precomputed array of spline tension factors from
            `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

    Returns:
        zgrid : array of floats, shape(nj,ni)
            interpolated values defined by gridded lons/lats
    &#34;&#34;&#34;
    _emsg = {-1: &#34;n, ni, nj, or iflgg is outside its valid range.&#34;,\
             -2: &#34;nodes are collinear.&#34;,\
             -3: &#34;extrapolation failed due to the uniform grid extending \
                  too far beyond the triangulation boundary&#34;}


    if zdata.size != self.npoints:
        raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

    zdata = self._shuffle_field(zdata)
    grad, iflgg = self._check_gradient(zdata, grad)
    sigma, iflgs = self._check_sigma(sigma)
    
    nrow = len(lats)


    ff, ierr = _ssrfpack.unif(self._x, self._y, self._z, zdata,\
                              self.lst, self.lptr, self.lend,\
                              iflgs, sigma, nrow, lats, lons,\
                              iflgg, grad)

    if ierr &lt; 0:
        raise ValueError(_emsg[ierr])

    return ff</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, t2, unique=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Join this triangulation with another. If the points are known to have no duplicates, then
set unique=True to skip the testing and duplicate removal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, t2, unique=False):
    &#34;&#34;&#34;
    Join this triangulation with another. If the points are known to have no duplicates, then
    set unique=True to skip the testing and duplicate removal
    &#34;&#34;&#34;

    lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
    latv1 = np.concatenate((self.lats, t2.lats), axis=0)

    ## remove any duplicates

    if not unique:
        lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.lons_map_to_wrapped"><code class="name flex">
<span>def <span class="ident">lons_map_to_wrapped</span></span>(<span>self, lon)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lons_map_to_wrapped(self, lon):

    lons = np.array(lon)
    lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

    return lons</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">midpoint_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def midpoint_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.nearest_vertex"><code class="name flex">
<span>def <span class="ident">nearest_vertex</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<div class="desc"><p>Locate the index of the nearest vertex to points (lons,lats)
and return the squared great circle distance between (lons,lats) and
each nearest neighbour.</p>
<h2 id="args">Args</h2>
<p>lons : float / array of floats, shape (l,)
longitudinal coordinate(s) on the sphere
lats : float / array of floats, shape (l,)
latitudinal coordinate(s) on the sphere</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>index </code></dt>
<dd>array of ints
the nearest vertex to each of the supplied points</dd>
<dt><code>dist </code></dt>
<dd>array of floats
great circle distance (angle) on the unit sphere to the closest
vertex identified.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Faster searches can be obtained using a k-d tree.
See <code><a title="stripy.spherical.sTriangulation.nearest_vertices" href="#stripy.spherical.sTriangulation.nearest_vertices">sTriangulation.nearest_vertices()</a></code> for details.
There is an additional overhead associated with building and storing the k-d tree.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_vertex(self, lons, lats):
    &#34;&#34;&#34;
    Locate the index of the nearest vertex to points (lons,lats)
    and return the squared great circle distance between (lons,lats) and
    each nearest neighbour.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere

    Returns:
        index : array of ints
            the nearest vertex to each of the supplied points
        dist : array of floats
            great circle distance (angle) on the unit sphere to the closest
            vertex identified.

    Notes:
        Faster searches can be obtained using a k-d tree.
        See `sTriangulation.nearest_vertices()` for details.
        There is an additional overhead associated with building and storing the k-d tree.

    &#34;&#34;&#34;

    # translate to unit sphere

    xi = np.array(_stripack.trans(lats, lons))
    idx = np.empty_like(xi[0,:], dtype=int)
    dist = np.empty_like(xi[0,:], dtype=float)

    for pt in range(0, xi.shape[1]):
        xi0 = xi[:,pt]

        # i is the node at which we start the search
        # the closest x coordinate is a good place
        i = ((self._x - xi0[0])**2).argmin() + 1

        idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

    idx -= 1 # return to C ordering

    return self._deshuffle_simplices(idx), dist</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.nearest_vertices"><code class="name flex">
<span>def <span class="ident">nearest_vertices</span></span>(<span>self, lon, lat, k=1, max_distance=2.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the cKDtree for the nearest neighbours and Euclidean
distance from x,y points.</p>
<p>Returns 0, 0 if a cKDtree has not been constructed
(switch <code>tree=True</code> if you need this routine)</p>
<h2 id="args">Args</h2>
<p>lon : 1D array
longitudinal coordinates in radians
lat : 1D array
latitudinal coordinates in radians
k : int (default: 1)
number of nearest neighbours to return
max_distance : float (default: 2.0)
maximum Euclidean distance to search for neighbours</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>d </code></dt>
<dd>array of floats
Euclidean distance between each point and their
nearest neighbour(s)</dd>
<dt><code>vert </code></dt>
<dd>array of ints
vertices of the nearest neighbour(s)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
    &#34;&#34;&#34;
    Query the cKDtree for the nearest neighbours and Euclidean
    distance from x,y points.

    Returns 0, 0 if a cKDtree has not been constructed
    (switch `tree=True` if you need this routine)

    Args:
        lon : 1D array
            longitudinal coordinates in radians
        lat : 1D array
            latitudinal coordinates in radians
        k : int (default: 1)
            number of nearest neighbours to return
        max_distance : float (default: 2.0)
            maximum Euclidean distance to search for neighbours

    Returns:
        d : array of floats
            Euclidean distance between each point and their
            nearest neighbour(s)
        vert : array of ints
            vertices of the nearest neighbour(s)
    &#34;&#34;&#34;

    if self.tree == False or self.tree == None:
        return 0, 0

    lons = np.array(lon).reshape(-1,1)
    lats = np.array(lat).reshape(-1,1)

    xyz = np.empty((lons.shape[0],3))
    x,y,z = lonlat2xyz(lons, lats)

    xyz[:,0] = x[:].reshape(-1)
    xyz[:,1] = y[:].reshape(-1)
    xyz[:,2] = z[:].reshape(-1)

    dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


    if k == 1:   # force this to be a 2D array
        vertices = np.reshape(vertices, (-1, 1))

    ## Now find the angular separation / great circle distance: dlatlon


    vertxyz = self.points[vertices].transpose(0,2,1)
    extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

    angles = np.arccos((extxyz * vertxyz).sum(axis=1))

    return angles, vertices</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.neighbour_and_arc_simplices"><code class="name flex">
<span>def <span class="ident">neighbour_and_arc_simplices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get indices of neighbour simplices for each simplex and arc indices.
Identical to get_neighbour_simplices() but also returns an array
of indices that reside on boundary hull, -1 denotes no neighbour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbour_and_arc_simplices(self):
    &#34;&#34;&#34;
    Get indices of neighbour simplices for each simplex and arc indices.
    Identical to get_neighbour_simplices() but also returns an array
    of indices that reside on boundary hull, -1 denotes no neighbour.
    &#34;&#34;&#34;
    nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=9)
    if ierr != 0:
        raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
    ltri = ltri.T[:nt] - 1
    return ltri[:,3:6], ltri[:,6:]</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.neighbour_simplices"><code class="name flex">
<span>def <span class="ident">neighbour_simplices</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get indices of neighbour simplices for each simplex.
The kth neighbour is opposite to the kth vertex.
For simplices at the boundary, -1 denotes no neighbour.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def neighbour_simplices(self):
    &#34;&#34;&#34;
    Get indices of neighbour simplices for each simplex.
    The kth neighbour is opposite to the kth vertex.
    For simplices at the boundary, -1 denotes no neighbour.
    &#34;&#34;&#34;
    nt, ltri, ierr = _stripack.trlist(self.lst, self.lptr, self.lend, nrow=6)
    if ierr != 0:
        raise ValueError(&#39;ierr={} in trlist\n{}&#39;.format(ierr, _ier_codes[ierr]))
    return ltri.T[:nt,3:] - 1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_midpoints"><code class="name flex">
<span>def <span class="ident">segment_midpoints</span></span>(<span>self, segments=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify the midpoints of every line segment in the triangulation.
If an array of segments of shape (no_of_segments,2) is given,
then the midpoints of only those segments is returned. Note,
segments in the array must not be duplicates or the re-triangulation
will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_midpoints(self, segments=None):
    &#34;&#34;&#34;
    Identify the midpoints of every line segment in the triangulation.
    If an array of segments of shape (no_of_segments,2) is given,
    then the midpoints of only those segments is returned. Note,
    segments in the array must not be duplicates or the re-triangulation
    will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
    &#34;&#34;&#34;

    if type(segments) == type(None):
        segments = self.identify_segments()
    points = self.points

    mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
    mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

    lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return lons, lats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_midpoints_by_vertices"><code class="name flex">
<span>def <span class="ident">segment_midpoints_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<div class="desc"><p>Add midpoints to any segment connected to the vertices in the
list / array provided.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_midpoints_by_vertices(self, vertices):
    &#34;&#34;&#34;
    Add midpoints to any segment connected to the vertices in the
    list / array provided.
    &#34;&#34;&#34;

    segments = set()

    for vertex in vertices:
        neighbours = self.identify_vertex_neighbours(vertex)
        segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

    segs = np.array(list(segments))

    new_midpoint_lonlats = self.segment_midpoints(segments=segs)

    return new_midpoint_lonlats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_tripoints"><code class="name flex">
<span>def <span class="ident">segment_tripoints</span></span>(<span>self, ratio=0.33333)</span>
</code></dt>
<dd>
<div class="desc"><p>Identify the trisection points of every line segment in the triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_tripoints(self, ratio=0.33333):
    &#34;&#34;&#34;
    Identify the trisection points of every line segment in the triangulation
    &#34;&#34;&#34;

    segments = self.identify_segments()
    points = self.points

    mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
    mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

    mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
    mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

    mids = np.vstack((mids1,mids2))

    midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return midlls</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.smoothing"><code class="name flex">
<span>def <span class="ident">smoothing</span></span>(<span>self, f, w, sm, smtol, gstol, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Smooths a surface f by choosing nodal function values and gradients to
minimize the linearized curvature of F subject to a bound on the
deviation from the data values. This is more appropriate than interpolation
when significant errors are present in the data.</p>
<h2 id="args">Args</h2>
<p>f : array of floats, shape (n,)
field to apply smoothing on
w : array of floats, shape (n,)
weights associated with data value in f
w[i] = 1/sigma_f^2 is a good rule of thumb.
sm : float
positive parameter specifying an upper bound on Q2(f).
generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
smtol : float
specifies relative error in satisfying the constraint
sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
gstol : float
tolerance for convergence.
gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.
sigma : array of floats, shape (6n-12)
precomputed array of spline tension factors from
<code>get_spline_tension_factors(zdata, tol=1e-3, grad=None)</code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>f_smooth </code></dt>
<dd>array of floats, shape (n,)
smoothed version of f</dd>
<dt><code>derivatives </code></dt>
<dd>tuple of floats, shape (n,3)
(dfdx, dfdy, dfdz) first derivatives of f_smooth in the
x, y, and z directions</dd>
<dt><code>err </code></dt>
<dd>error indicator
0 indicates no error, +ve values indicate warnings, -ve values are errors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def smoothing(self, f, w, sm, smtol, gstol, sigma=None):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.
            sigma : array of floats, shape (6n-12)
                precomputed array of spline tension factors from
                `get_spline_tension_factors(zdata, tol=1e-3, grad=None)`

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma, iflgs = self._check_sigma(sigma)
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f,\
                                              self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            print(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.tri_area"><code class="name flex">
<span>def <span class="ident">tri_area</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the area enclosed by 3 points on the unit sphere.</p>
<h2 id="args">Args</h2>
<p>lons : array of floats, shape (3)
longitudinal coordinates in radians
lats : array of floats, shape (3)
latitudinal coordinates in radians</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>area </code></dt>
<dd>float
area of triangle on the unit sphere</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_area(self, lons, lats):
    &#34;&#34;&#34;
    Calculate the area enclosed by 3 points on the unit sphere.

    Args:
        lons : array of floats, shape (3)
            longitudinal coordinates in radians
        lats : array of floats, shape (3)
            latitudinal coordinates in radians

    Returns:
        area : float
            area of triangle on the unit sphere

    &#34;&#34;&#34;
    lons, lats = self._check_integrity(lons, lats)

    # translate to unit sphere
    x, y, z = _stripack.trans(lats, lons)

    # compute area
    area = _stripack.areas(x, y, z)

    return area</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.uniformly_refine_triangulation"><code class="name flex">
<span>def <span class="ident">uniformly_refine_triangulation</span></span>(<span>self, faces=False, trisect=False)</span>
</code></dt>
<dd>
<div class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniformly_refine_triangulation(self, faces=False, trisect=False):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation
    &#34;&#34;&#34;

    if faces:
        lonv1, latv1 = self._add_face_centroids()

    else:
        if not trisect:
            lonv1, latv1 = self._add_spherical_midpoints()
        else:
            lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.update_tension_factors"><code class="name flex">
<span>def <span class="ident">update_tension_factors</span></span>(<span>self, zdata, tol=0.001, grad=None)</span>
</code></dt>
<dd>
<div class="desc"><p>WARNING: this is deprecated in favour of <code>get_spline_tension_factors</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_tension_factors(self, zdata, tol=1e-3, grad=None):
    &#34;&#34;&#34;
    WARNING: this is deprecated in favour of `get_spline_tension_factors`
    &#34;&#34;&#34;
    import warnings
    message = &#34;Use get_spline_tension_factors and supply tension factors to interpolation/gradient arrays&#34;
    message += &#34;\nsigma stored on this mesh object no longer does anything as of v2.0&#34;
    warnings.warn(message, DeprecationWarning, stacklevel=2)
    return self.get_spline_tension_factors(zdata, tol, grad)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.voronoi_points"><code class="name flex">
<span>def <span class="ident">voronoi_points</span></span>(<span>self, return_circumradius=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the voronoi points from the triangulation.</p>
<p>This routine returns the circumcentre, circumradius of each triangle.</p>
<h2 id="args">Args</h2>
<p>return_circumradius : bool
optionally return circumradius of each circumcentre</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>vlons </code></dt>
<dd>ndarray of floats
longitudinal coordinates of the Voronoi</dd>
<dt><code>vlats </code></dt>
<dd>ndarray of floats
latitudinal coordinates of the Voronoi</dd>
<dt><code>cr </code></dt>
<dd>ndarray of floats (optional)
coordinates of the circumcentre (centre of the circle
defined by three points in a triangle)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def voronoi_points(self, return_circumradius=False):
    &#34;&#34;&#34;
    Calculates the voronoi points from the triangulation.

    This routine returns the circumcentre, circumradius of each triangle.

    Args:
        return_circumradius : bool
            optionally return circumradius of each circumcentre

    Returns:
        vlons : ndarray of floats
            longitudinal coordinates of the Voronoi
        vlats : ndarray of floats
            latitudinal coordinates of the Voronoi
        cr : ndarray of floats (optional)
            coordinates of the circumcentre (centre of the circle
            defined by three points in a triangle)
    &#34;&#34;&#34;

    # get x,y,z coordinates for each triangle
    simplices = self.simplices
    xt = self.x[simplices]
    yt = self.y[simplices]
    zt = self.z[simplices]

    # construct 3-component vectors
    v1 = np.column_stack([xt[:,0], yt[:,0], zt[:,0]])
    v2 = np.column_stack([xt[:,1], yt[:,1], zt[:,1]])
    v3 = np.column_stack([xt[:,2], yt[:,2], zt[:,2]])

    # get edge lengths
    e1 = v2 - v1
    e2 = v3 - v1

    # compute scalar multiples of e1 * e2
    cu = np.empty_like(xt)
    cu[:,0] = e1[:,1]*e2[:,2] - e1[:,2]*e2[:,1]
    cu[:,1] = e1[:,2]*e2[:,0] - e1[:,0]*e2[:,2]
    cu[:,2] = e1[:,0]*e2[:,1] - e1[:,1]*e2[:,0]

    # compute normal vector
    cnorm = np.sqrt( (cu**2).sum(axis=1) )

    coords = cu / cnorm.reshape(-1,1)
    xc, yc, zc = coords[:,0], coords[:,1], coords[:,2]

    # convert to lon/lat
    vlons, vlats = xyz2lonlat(xc,yc,zc)

    out = [vlons, vlats]

    if return_circumradius:
        tr = (v1*coords).sum(axis=1)
        tr = np.clip(tr, -1.0, 1.0)
        cr = np.arccos(tr)
        out.append( cr )

    return tuple(out)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.voronoi_points_and_regions"><code class="name flex">
<span>def <span class="ident">voronoi_points_and_regions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the voronoi points from the triangulation
and constructs the region enclosed by them.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>vlons </code></dt>
<dd>ndarray of floats
longitudinal coordinates of the Voronoi</dd>
<dt><code>vlats </code></dt>
<dd>ndarray of floats
latitudinal coordinates of the Voronoi</dd>
<dt><code>regions </code></dt>
<dd>list of ints
a nested list of all Voronoi indices that
enclose a region.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Inifinite regions are not indicated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def voronoi_points_and_regions(self):
    &#34;&#34;&#34;
    Calculates the voronoi points from the triangulation
    and constructs the region enclosed by them.

    Returns:
        vlons : ndarray of floats
            longitudinal coordinates of the Voronoi
        vlats : ndarray of floats
            latitudinal coordinates of the Voronoi
        regions : list of ints
            a nested list of all Voronoi indices that
            enclose a region.

    Notes:
        Inifinite regions are not indicated.
    &#34;&#34;&#34;

    vx, vy = self.voronoi_points()

    # store these to avoid any shuffle/reshuffle later
    simplices = self.simplices
    x = self.lons
    y = self.lats

    # empty placeholder array for vertices
    voronoi_regions = [[] for i in range(0, self.npoints)]

    # create regions for each point in the Delaunay triangulation
    for i, (t0,t1,t2) in enumerate(simplices):
        voronoi_regions[t0].append(i)
        voronoi_regions[t1].append(i)
        voronoi_regions[t2].append(i)

    # sort the vertices around each site
    # there is probably a more efficient way using the neighbour adjacency info
    for i in range(0, self.npoints):
        region = np.array(voronoi_regions[i])
        dx = vx[region] - x[i]
        dy = vy[region] - y[i]
        idx = np.arctan2(dx, dy).argsort() # this could be a problem across the dateline
        voronoi_regions[i] = region[idx]

    return vx, vy, voronoi_regions</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stripy" href="index.html">stripy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="stripy.spherical.angular_separation" href="#stripy.spherical.angular_separation">angular_separation</a></code></li>
<li><code><a title="stripy.spherical.dxyz2dlonlat" href="#stripy.spherical.dxyz2dlonlat">dxyz2dlonlat</a></code></li>
<li><code><a title="stripy.spherical.great_circle_Npoints" href="#stripy.spherical.great_circle_Npoints">great_circle_Npoints</a></code></li>
<li><code><a title="stripy.spherical.lonlat2xyz" href="#stripy.spherical.lonlat2xyz">lonlat2xyz</a></code></li>
<li><code><a title="stripy.spherical.remove_duplicate_lonlat" href="#stripy.spherical.remove_duplicate_lonlat">remove_duplicate_lonlat</a></code></li>
<li><code><a title="stripy.spherical.xyz2lonlat" href="#stripy.spherical.xyz2lonlat">xyz2lonlat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stripy.spherical.sTriangulation" href="#stripy.spherical.sTriangulation">sTriangulation</a></code></h4>
<ul class="">
<li><code><a title="stripy.spherical.sTriangulation.angular_separation" href="#stripy.spherical.sTriangulation.angular_separation">angular_separation</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.areas" href="#stripy.spherical.sTriangulation.areas">areas</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles" href="#stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles">centroid_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices">centroid_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.containing_simplex_and_bcc" href="#stripy.spherical.sTriangulation.containing_simplex_and_bcc">containing_simplex_and_bcc</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.containing_triangle" href="#stripy.spherical.sTriangulation.containing_triangle">containing_triangle</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.derivatives_lonlat" href="#stripy.spherical.sTriangulation.derivatives_lonlat">derivatives_lonlat</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_lengths" href="#stripy.spherical.sTriangulation.edge_lengths">edge_lengths</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles" href="#stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles">edge_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices">edge_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.face_midpoints" href="#stripy.spherical.sTriangulation.face_midpoints">face_midpoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.get_spline_tension_factors" href="#stripy.spherical.sTriangulation.get_spline_tension_factors">get_spline_tension_factors</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.gradient_lonlat" href="#stripy.spherical.sTriangulation.gradient_lonlat">gradient_lonlat</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.gradient_xyz" href="#stripy.spherical.sTriangulation.gradient_xyz">gradient_xyz</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_segments" href="#stripy.spherical.sTriangulation.identify_segments">identify_segments</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_vertex_neighbours" href="#stripy.spherical.sTriangulation.identify_vertex_neighbours">identify_vertex_neighbours</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_vertex_triangles" href="#stripy.spherical.sTriangulation.identify_vertex_triangles">identify_vertex_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate" href="#stripy.spherical.sTriangulation.interpolate">interpolate</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_cubic" href="#stripy.spherical.sTriangulation.interpolate_cubic">interpolate_cubic</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_linear" href="#stripy.spherical.sTriangulation.interpolate_linear">interpolate_linear</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_nearest" href="#stripy.spherical.sTriangulation.interpolate_nearest">interpolate_nearest</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_to_grid" href="#stripy.spherical.sTriangulation.interpolate_to_grid">interpolate_to_grid</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.join" href="#stripy.spherical.sTriangulation.join">join</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lats" href="#stripy.spherical.sTriangulation.lats">lats</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lons" href="#stripy.spherical.sTriangulation.lons">lons</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lons_map_to_wrapped" href="#stripy.spherical.sTriangulation.lons_map_to_wrapped">lons_map_to_wrapped</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices">midpoint_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.nearest_vertex" href="#stripy.spherical.sTriangulation.nearest_vertex">nearest_vertex</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.nearest_vertices" href="#stripy.spherical.sTriangulation.nearest_vertices">nearest_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.neighbour_and_arc_simplices" href="#stripy.spherical.sTriangulation.neighbour_and_arc_simplices">neighbour_and_arc_simplices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.neighbour_simplices" href="#stripy.spherical.sTriangulation.neighbour_simplices">neighbour_simplices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.points" href="#stripy.spherical.sTriangulation.points">points</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_midpoints" href="#stripy.spherical.sTriangulation.segment_midpoints">segment_midpoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_midpoints_by_vertices" href="#stripy.spherical.sTriangulation.segment_midpoints_by_vertices">segment_midpoints_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_tripoints" href="#stripy.spherical.sTriangulation.segment_tripoints">segment_tripoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.simplices" href="#stripy.spherical.sTriangulation.simplices">simplices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.smoothing" href="#stripy.spherical.sTriangulation.smoothing">smoothing</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.tri_area" href="#stripy.spherical.sTriangulation.tri_area">tri_area</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.uniformly_refine_triangulation" href="#stripy.spherical.sTriangulation.uniformly_refine_triangulation">uniformly_refine_triangulation</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.update_tension_factors" href="#stripy.spherical.sTriangulation.update_tension_factors">update_tension_factors</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.voronoi_points" href="#stripy.spherical.sTriangulation.voronoi_points">voronoi_points</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.voronoi_points_and_regions" href="#stripy.spherical.sTriangulation.voronoi_points_and_regions">voronoi_points_and_regions</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.x" href="#stripy.spherical.sTriangulation.x">x</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.y" href="#stripy.spherical.sTriangulation.y">y</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.z" href="#stripy.spherical.sTriangulation.z">z</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>