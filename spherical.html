<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>stripy.spherical API documentation</title>
<meta name="description" content="Copyright 2017-2019 Louis Moresi, Ben Mather â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>stripy.spherical</code></h1>
</header>
<section id="section-intro">
<p>Copyright 2017-2019 Louis Moresi, Ben Mather</p>
<p>This file is part of Stripy.</p>
<p>Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the
GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License
along with Stripy.
If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Copyright 2017-2019 Louis Moresi, Ben Mather

This file is part of Stripy.

Stripy is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or any later version.

Stripy is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Stripy.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
&#34;&#34;&#34;

#!/usr/bin/python
# -*- coding: utf-8 -*-
from . import _stripack
from . import _ssrfpack
import numpy as np

try: range = xrange
except: pass

_ier_codes = {0:  &#34;no errors were encountered.&#34;,
              -1: &#34;N &lt; 3 on input.&#34;,
              -2: &#34;the first three nodes lie on a great circle.\nSet permute to True or reorder nodes manually.&#34;,
              -3: &#34;duplicate nodes were encountered.&#34;,
              -4: &#34;an error flag was returned by a call to SWAP in ADDNOD.\n \
                   This is an internal error and should be reported to the programmer.&#34;,
              &#39;L&#39;:&#34;nodes L and M coincide for some M &gt; L.\n \
                   The linked list represents a triangulation of nodes 1 to M-1 in this case.&#34;,
              1: &#34;NCC, N, NROW, or an LCC entry is outside its valid range on input.&#34;,
              2: &#34;the triangulation data structure (LIST,LPTR,LEND) is invalid.&#34;,
              &#39;K&#39;: &#39;NPTS(K) is not a valid index in the range 1 to N.&#39;,
              9999: &#34;Triangulation encountered duplicate nodes.&#34;}


class sTriangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given points on a sphere
    where lons and lats are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
        and Voronoi diagram on the surface of a sphere&#34;
        ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
        doi:10.1145/275323.275329

    Args:
        lons : 1D array
            longitudinal coordinates in radians
        lats : 1D array
            latitudinal coordinates in radians
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        lons : array of floats, shape (n,)
            stored longitudinal coordinates on a sphere
        lats : array of floats, shape (n,)
            stored latitudinal coordinates on a sphere
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        z : array of floats, shape (n,)
            stored Cartesian z coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity O(N*log(N)) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as O(N**2) if, for example, the nodes are ordered
        on increasing latitude.

        if permute=True, lons and lats are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting permute=True and permute=False,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, lons, lats, refinement_levels=0, permute=False, tree=False):

        # lons, lats = self._check_integrity(lons, lats)
        self.permute = permute
        self.tree = tree

        self._update_triangulation(lons, lats)

        for r in range(0,refinement_levels):
            lons, lats = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(lons,lats)

        return

    def _generate_permutation(self, npoints):
        &#34;&#34;&#34;
        Create shuffle and deshuffle vectors
        &#34;&#34;&#34;
        i = np.arange(0, npoints)
        # permutation
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        # inverse permutation
        ip[p[i]] = i
        return p, ip



    def _is_collinear(self, lons, lats):
        &#34;&#34;&#34;
        Checks if first three points are collinear - in the spherical
        case this corresponds to all points lying on a great circle
        and, hence, all coordinate vectors being in a single plane.
        &#34;&#34;&#34;

        x, y, z = lonlat2xyz(lons[:3], lats[:3])
        pts = np.column_stack([x, y, z])

        collinearity = (np.linalg.det(pts.T) == 0.0)

        return collinearity


    def _update_triangulation(self, lons, lats):

        npoints = len(lons)

        # Deal with collinear issue

        if self.permute:
            # Store permutation vectors to shuffle/deshuffle lons and lats
            niter = 0
            ierr = -2
            while ierr==-2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                lons = lons[p]
                lats = lats[p]
                # compute cartesian coords on unit sphere.
                x, y, z = _stripack.trans(lats, lons)
                lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            # compute cartesian coords on unit sphere.
            x, y, z = _stripack.trans(lats, lons)
            lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._lons = lons
        self._lats = lats
        self._x = x
        self._y = y
        self._z = z
        self._points = np.column_stack([x, y, z])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _stripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        ## np.ndarray.sort(self.simplices, axis=1)

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

    @property
    def lons(self):
        &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lons)
    @property
    def lats(self):
        &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lats)
    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def z(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._z)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the lon / lat components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, guarantee_convergence=guarantee_convergence)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        corr = np.sqrt((1.0-z**2))
        valid = ~np.isclose(corr,0.0)

        dlon[valid] = dlon[valid] / corr[valid]

        return dlon, dlat


    def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the cartesian components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction
            dfdz : array of floats, shape (n,)
                derivative of f in the z direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
            derivative of F with respect to distance T along the arc.
        &#34;&#34;&#34;

        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=np.float32)
        sigma = 0
        iflgs = 0

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                                   iflgs, sigma, nit, tol)
            if not guarantee_convergence:
                break

        if ierr &lt; 0:
            warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(grad[0], grad[1], grad[2])


    def smoothing(self, f, w, sm, smtol, gstol):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma = 0
        iflgs = 0
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr



    def _check_integrity(self, lons, lats):
        &#34;&#34;&#34;
        Ensure lons and lats are:
         - 1D numpy arrays
         - equal size
         - within the appropriate range in radians
        &#34;&#34;&#34;

        lons = np.array(lons).ravel()
        lats = np.array(lats).ravel()

        if len(lons.shape) != 1 or len(lats.shape) != 1:
            raise ValueError(&#39;lons and lats must be 1D&#39;)
        if lats.size != lons.size:
            raise ValueError(&#39;lons and lats must have same length&#39;)
        if (np.abs(lons)).max() &gt; 2.*np.pi:
            raise ValueError(&#34;lons must be in radians (-2*pi &lt;= lon &lt;= 2*pi)&#34;)
        if (np.abs(lats)).max() &gt; 0.5*np.pi:
            raise ValueError(&#34;lats must be in radians (-pi/2 &lt;= lat &lt;= pi/2)&#34;)
        return lons, lats





    def interpolate(self, lons, lats, zdata, order=1):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes on the unit sphere, along with data
        values at the nodes, this method interpolates (or extrapolates) the value
        at a given longitude and latitude.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used
                    0 = nearest-neighbour
                    1 = linear
                    3 = cubic

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) at (lons, lats)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;


        shape = np.array(lons).shape

        lons, lats = self._check_integrity(lons, lats)

        if order not in [0,1,3]:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)
        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)

        zi, zierr, ierr = _stripack.interp_n(order, lats, lons,\
                                      self._x, self._y, self._z, zdata,\
                                      self.lst, self.lptr, self.lend)

        import warnings

        if ierr != 0:
            warnings.warn(&#39;Warning some points may have errors - check error array\n&#39;.format(ierr))
            zi[zierr &lt; 0] = np.nan

        return zi.reshape(shape), zierr.reshape(shape)


    def interpolate_nearest(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using nearest-neighbour approximation
        Returns the same as `interpolate(lons,lats,data,order=0)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=0)

    def interpolate_linear(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using linear approximation
        Returns the same as `interpolate(lons,lats,data,order=1)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=1)

    def interpolate_cubic(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using cubic spline approximation
        Returns the same as `interpolate(lons,lats,data,order=3)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=3)


    def nearest_vertex(self, lons, lats):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (lons,lats)
        and return the squared great circle distance between (lons,lats) and
        each nearest neighbour.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                great circle distance (angle) on the unit sphere to the closest
                vertex identified.

        Notes:
            Faster searches can be obtained using a k-d tree.
            See `sTriangulation.nearest_vertices()` for details.
            There is an additional overhead associated with building and storing the k-d tree.

        &#34;&#34;&#34;

        # translate to unit sphere

        xi = np.array(_stripack.trans(lats, lons))
        idx = np.empty_like(xi[0,:], dtype=np.int)
        dist = np.empty_like(xi[0,:], dtype=np.float)

        for pt in range(0, xi.shape[1]):
            xi0 = xi[:,pt]

            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = ((self._x - xi0[0])**2).argmin() + 1

            idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, lons, lats):
        &#34;&#34;&#34;
        Returns indices of the triangles containing lons / lats.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            tri_indices : array of ints, shape (l,)
                indices of containing triangle


        Notes:
            The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

        &#34;&#34;&#34;
        p = self._permutation
        pts = np.array(lonlat2xyz(lons,lats)).T

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri = np.sort(t[3:6]) - 1

            triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).reshape(-1)


    def containing_simplex_and_bcc(self, lons, lats):
        &#34;&#34;&#34;
        Returns the simplices containing (lons,lats)
        and the local barycentric, normalised coordinates.

        Args:
            lons : float / array of floats, shape(l,)
                longitudinal coordinates in radians
            lats :  float / array of floats, shape(l,)
                latitudinal coordinates in radians

        Returns:
            bcc  : normalised barycentric coordinates
            tri  : simplicies containing (lons,lats)

        Notes:
            That the ordering of the vertices may differ from
            that stored in the self.simplices array but will
            still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.array(lonlat2xyz(lons,lats)).T

        tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
        bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri[i] = t[3:6]
            bcc[i] = t[0:3]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        (from the data structures of the triangulation)
        &#34;&#34;&#34;
        vertex = self._permutation[vertex]

        lpl = self.lend[vertex-1]
        lp = lpl

        neighbours = []

        while True:
            lp = self.lptr[lp-1]
            neighbours.append(self.lst[lp-1]-1)
            if (lp == lpl):
                break

        return self._deshuffle_simplices(neighbours)


    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))



    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        lst  = self.lst
        lend = self.lend
        lptr = self.lptr

        segments_array = np.empty((len(lptr),2),dtype=np.int)
        segments_array[:,0] = lst[:] - 1
        segments_array[:,1] = lst[lptr[:]-1] - 1

        valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
        segments = segments_array[valid,:]

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoint_lonlats = self.segment_midpoints(segments=segs)

        return new_midpoint_lonlats


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlons, midlats


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned. Note,
        segments in the array must not be duplicates or the re-triangulation
        will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return lons, lats

    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
        mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

        mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
        mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

        mids = np.vstack((mids1,mids2))

        midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlls


    def lons_map_to_wrapped(self, lon):

        lons = np.array(lon)
        lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

        return lons

    def tri_area(self, lons, lats):
        &#34;&#34;&#34;
        Calculate the area enclosed by 3 points on the unit sphere.

        Args:
            lons : array of floats, shape (3)
                longitudinal coordinates in radians
            lats : array of floats, shape (3)
                latitudinal coordinates in radians

        Returns:
            area : float
                area of triangle on the unit sphere

        &#34;&#34;&#34;
        lons, lats = self._check_integrity(lons, lats)

        # translate to unit sphere
        x, y, z = _stripack.trans(lats, lons)

        # compute area
        area = _stripack.areas(x, y, z)

        return area



    def areas(self):
        &#34;&#34;&#34;
        Compute the area each triangle within the triangulation of points
        on the unit sphere.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in self.simplices where nt
                is the number of triangles.

        Notes:
            This uses a Fortran 90 subroutine that wraps the AREA function
            to iterate over many points.
        &#34;&#34;&#34;

        return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;

        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        ## dot products to obtain angles
        ab = np.arccos((a * b).sum(axis=1))
        bc = np.arccos((b * c).sum(axis=1))
        ac = np.arccos((a * c).sum(axis=1))

        ## As this is a unit sphere, angle = length so ...

        return ab, bc, ac

    def angular_separation(self, lonp1, latp1, lonp2, latp2):
        &#34;&#34;&#34;
        Compute the angles between lon / lat points p1 and p2 given in radians.
        On the unit sphere, this also corresponds to the great circle distance.
        p1 and p2 can be numpy arrays of the same length.

        This method simply calls the module-level function of the same name.
        Consider using the module function instead, as this method may be
        deprecated in favor of that function. For now, this method is
        retained to avoid issues with the Jupyter notebooks.
        &#34;&#34;&#34;
        # Call the module-level function
        return angular_separation(lonp1, latp1, lonp2, latp2)

    def _add_spherical_midpoints(self):

        midlon_array, midlat_array = self.segment_midpoints()

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_spherical_tripoints(self, ratio=0.333333):

        midlon_array, midlat_array = self.segment_tripoints(ratio=ratio)

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_face_centroids(self):

        facelon_array, facelat_array = self.face_midpoints()

        lonv2 = np.concatenate((self.lons, facelon_array), axis=0)
        latv2 = np.concatenate((self.lats, facelat_array), axis=0)

        return lonv2, latv2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            lonv1, latv1 = self._add_face_centroids()

        else:
            if not trisect:
                lonv1, latv1 = self._add_spherical_midpoints()
            else:
                lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


        return lonv1, latv1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1




    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i].`
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        mlons, mlats = self.segment_midpoints(segs)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)



    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)



    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=True to skip the testing and duplicate removal
        &#34;&#34;&#34;

        lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
        latv1 = np.concatenate((self.lats, t2.lats), axis=0)

        ## remove any duplicates

        if not unique:
            lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

        return lonv1, latv1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree =  scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            lon : 1D array
                longitudinal coordinates in radians
            lat : 1D array
                latitudinal coordinates in radians
            k : int (default: 1)
                number of nearest neighbours to return
            max_distance : float (default: 2.0)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        lons = np.array(lon).reshape(-1,1)
        lats = np.array(lat).reshape(-1,1)

        xyz = np.empty((lons.shape[0],3))
        x,y,z = lonlat2xyz(lons, lats)

        xyz[:,0] = x[:].reshape(-1)
        xyz[:,1] = y[:].reshape(-1)
        xyz[:,2] = z[:].reshape(-1)

        dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        ## Now find the angular separation / great circle distance: dlatlon


        vertxyz = self.points[vertices].transpose(0,2,1)
        extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

        angles = np.arccos((extxyz * vertxyz).sum(axis=1))

        return angles, vertices




## Helper functions for the module

def remove_duplicate_lonlat(lon, lat):
    &#34;&#34;&#34;
    remove duplicates from an array of lon / lat points
    &#34;&#34;&#34;

    a = np.ascontiguousarray(np.vstack((lon, lat)).T)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    llunique = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

    lon1 = llunique[:,0]
    lat1 = llunique[:,1]

    return lon1, lat1


def lonlat2xyz(lon, lat):
    &#34;&#34;&#34;
    Convert lon / lat (radians) for the spherical triangulation into x,y,z
    on the unit sphere
    &#34;&#34;&#34;

    lons = np.array(lon)
    lats = np.array(lat)

    xs = np.cos(lats) * np.cos(lons)
    ys = np.cos(lats) * np.sin(lons)
    zs = np.sin(lats)

    return xs, ys, zs

def xyz2lonlat(x,y,z):
    &#34;&#34;&#34;
    Convert x,y,z representation of points *on the unit sphere* of the
    spherical triangulation to lon / lat (radians).

    Notes:
        no check is made here that (x,y,z) are unit vectors
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arcsin(zs)

    return lons, lats


def dxyz2dlonlat(x,y,z, dfx, dfy, dfz):
    &#34;&#34;&#34;
    Take stripack df/dx, df/dy, df/dz format and convert to
    surface gradients df/dlon, df/dlat
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arcsin(zs)

    dfxs = np.array(dfx)
    dfys = np.array(dfy)
    dfzs = np.array(dfz)

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-zs**2))
    valid = ~np.isclose(corr,0.0)

    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat


def great_circle_Npoints(lonlat1r, lonlat2r, N):
    &#34;&#34;&#34;
    N points along the line joining lonlat1 and lonlat2
    &#34;&#34;&#34;

    ratio = np.linspace(0.0,1.0, N).reshape(-1,1)


    xyz1 = lonlat2xyz(lonlat1r[0], lonlat1r[1])
    xyz2 = lonlat2xyz(lonlat2r[0], lonlat2r[1])

    mids = ratio * xyz2 + (1.0-ratio) * xyz1
    norm = np.sqrt((mids**2).sum(axis=1))
    xyzN = mids / norm.reshape(-1,1)

    lonlatN = xyz2lonlat( xyzN[:,0], xyzN[:,1], xyzN[:,2])

    return lonlatN


def angular_separation(lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.
    &#34;&#34;&#34;

    xp1, yp1, zp1 = lonlat2xyz(lonp1, latp1)
    xp2, yp2, zp2 = lonlat2xyz(lonp2, latp2)

    ## dot products to obtain angles

    angles = np.arccos((xp1 * xp2 + yp1 * yp2 + zp1 * zp2))

    ## As this is a unit sphere, angle = length

    return angles</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="stripy.spherical.angular_separation"><code class="name flex">
<span>def <span class="ident">angular_separation</span></span>(<span>lonp1, latp1, lonp2, latp2)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the angles between lon / lat points p1 and p2 given in radians.
On the unit sphere, this also corresponds to the great circle distance.
p1 and p2 can be numpy arrays of the same length.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_separation(lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.
    &#34;&#34;&#34;

    xp1, yp1, zp1 = lonlat2xyz(lonp1, latp1)
    xp2, yp2, zp2 = lonlat2xyz(lonp2, latp2)

    ## dot products to obtain angles

    angles = np.arccos((xp1 * xp2 + yp1 * yp2 + zp1 * zp2))

    ## As this is a unit sphere, angle = length

    return angles</code></pre>
</details>
</dd>
<dt id="stripy.spherical.dxyz2dlonlat"><code class="name flex">
<span>def <span class="ident">dxyz2dlonlat</span></span>(<span>x, y, z, dfx, dfy, dfz)</span>
</code></dt>
<dd>
<section class="desc"><p>Take stripack df/dx, df/dy, df/dz format and convert to
surface gradients df/dlon, df/dlat</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dxyz2dlonlat(x,y,z, dfx, dfy, dfz):
    &#34;&#34;&#34;
    Take stripack df/dx, df/dy, df/dz format and convert to
    surface gradients df/dlon, df/dlat
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arcsin(zs)

    dfxs = np.array(dfx)
    dfys = np.array(dfy)
    dfzs = np.array(dfz)

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-zs**2))
    valid = ~np.isclose(corr,0.0)

    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat</code></pre>
</details>
</dd>
<dt id="stripy.spherical.great_circle_Npoints"><code class="name flex">
<span>def <span class="ident">great_circle_Npoints</span></span>(<span>lonlat1r, lonlat2r, N)</span>
</code></dt>
<dd>
<section class="desc"><p>N points along the line joining lonlat1 and lonlat2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def great_circle_Npoints(lonlat1r, lonlat2r, N):
    &#34;&#34;&#34;
    N points along the line joining lonlat1 and lonlat2
    &#34;&#34;&#34;

    ratio = np.linspace(0.0,1.0, N).reshape(-1,1)


    xyz1 = lonlat2xyz(lonlat1r[0], lonlat1r[1])
    xyz2 = lonlat2xyz(lonlat2r[0], lonlat2r[1])

    mids = ratio * xyz2 + (1.0-ratio) * xyz1
    norm = np.sqrt((mids**2).sum(axis=1))
    xyzN = mids / norm.reshape(-1,1)

    lonlatN = xyz2lonlat( xyzN[:,0], xyzN[:,1], xyzN[:,2])

    return lonlatN</code></pre>
</details>
</dd>
<dt id="stripy.spherical.lonlat2xyz"><code class="name flex">
<span>def <span class="ident">lonlat2xyz</span></span>(<span>lon, lat)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert lon / lat (radians) for the spherical triangulation into x,y,z
on the unit sphere</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lonlat2xyz(lon, lat):
    &#34;&#34;&#34;
    Convert lon / lat (radians) for the spherical triangulation into x,y,z
    on the unit sphere
    &#34;&#34;&#34;

    lons = np.array(lon)
    lats = np.array(lat)

    xs = np.cos(lats) * np.cos(lons)
    ys = np.cos(lats) * np.sin(lons)
    zs = np.sin(lats)

    return xs, ys, zs</code></pre>
</details>
</dd>
<dt id="stripy.spherical.remove_duplicate_lonlat"><code class="name flex">
<span>def <span class="ident">remove_duplicate_lonlat</span></span>(<span>lon, lat)</span>
</code></dt>
<dd>
<section class="desc"><p>remove duplicates from an array of lon / lat points</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_duplicate_lonlat(lon, lat):
    &#34;&#34;&#34;
    remove duplicates from an array of lon / lat points
    &#34;&#34;&#34;

    a = np.ascontiguousarray(np.vstack((lon, lat)).T)
    unique_a = np.unique(a.view([(&#39;&#39;, a.dtype)]*a.shape[1]))
    llunique = unique_a.view(a.dtype).reshape((unique_a.shape[0], a.shape[1]))

    lon1 = llunique[:,0]
    lat1 = llunique[:,1]

    return lon1, lat1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.xyz2lonlat"><code class="name flex">
<span>def <span class="ident">xyz2lonlat</span></span>(<span>x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Convert x,y,z representation of points <em>on the unit sphere</em> of the
spherical triangulation to lon / lat (radians).</p>
<h2 id="notes">Notes</h2>
<p>no check is made here that (x,y,z) are unit vectors</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xyz2lonlat(x,y,z):
    &#34;&#34;&#34;
    Convert x,y,z representation of points *on the unit sphere* of the
    spherical triangulation to lon / lat (radians).

    Notes:
        no check is made here that (x,y,z) are unit vectors
    &#34;&#34;&#34;

    xs = np.array(x)
    ys = np.array(y)
    zs = np.array(z)

    lons = np.arctan2(ys, xs)
    lats = np.arcsin(zs)

    return lons, lats</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="stripy.spherical.sTriangulation"><code class="flex name class">
<span>class <span class="ident">sTriangulation</span></span>
<span>(</span><span>lons, lats, refinement_levels=0, permute=False, tree=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Define a Delaunay triangulation for given points on a sphere
where lons and lats are 1D numpy arrays of equal length.</p>
<h2 id="algorithm">Algorithm</h2>
<p>R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
and Voronoi diagram on the surface of a sphere"
ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
doi:10.1145/275323.275329</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>longitudinal coordinates in radians</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>latitudinal coordinates in radians</dd>
<dt><strong><code>refinement_levels</code></strong> :&ensp;<code>int</code></dt>
<dd>refine the number of points in the triangulation
(see uniformly_refine_triangulation)</dd>
<dt><strong><code>permute</code></strong> :&ensp;<code>bool</code></dt>
<dd>randomises the order of lons and lats to improve
triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)</dd>
<dt><strong><code>tree</code></strong> :&ensp;<code>bool</code></dt>
<dd>construct a cKDtree for efficient nearest-neighbour lookup</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored longitudinal coordinates on a sphere</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored latitudinal coordinates on a sphere</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored Cartesian x coordinates from input</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored Cartesian y coordinates from input</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>stored Cartesian z coordinates from input</dd>
<dt><strong><code>simplices</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>nsimplex</code>, <code>3</code>)</dt>
<dd>indices of the points forming the simplices in the triangulation
points are ordered anticlockwise</dd>
<dt><strong><code>lst</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>6n</code>-<code>12</code>,)</dt>
<dd>nodal indices with lptr and lend, define the triangulation as a set of N
adjacency lists; counterclockwise-ordered sequences of neighboring nodes
such that the first and last neighbors of a boundary node are boundary
nodes (the first neighbor of an interior node is arbitrary).
In order to
distinguish between interior and boundary nodes, the last neighbor of
each boundary node is represented by the negative of its index.
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
<dt><strong><code>lptr</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>6n</code>-<code>12</code>),)</dt>
<dd>set of pointers in one-to-one correspondence with the elements of lst.
lst(lptr(i)) indexes the node which follows lst(i) in cyclical
counterclockwise order (the first neighbor follows the last neighbor).
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
<dt><strong><code>lend</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>N pointers to adjacency lists.
lend(k) points to the last neighbor of node K.
lst(lend(K)) &lt; 0 if and only if K is a boundary node.
The indices are 1-based (as in Fortran), not zero based (as in python).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Provided the nodes are randomly ordered, the algorithm
has expected time complexity O(N<em>log(N)) for most nodal
distributions.
Note, however, that the complexity may be
as high as O(N</em>*2) if, for example, the nodes are ordered
on increasing latitude.</p>
<p>if permute=True, lons and lats are randomised on input before
they are triangulated. The distribution of triangles will
differ between setting permute=True and permute=False,
however, the node ordering will remain identical.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sTriangulation(object):
    &#34;&#34;&#34;
    Define a Delaunay triangulation for given points on a sphere
    where lons and lats are 1D numpy arrays of equal length.

    Algorithm:
        R. J. Renka (1997), Algorithm 772; STRIPACK: Delaunay triangulation
        and Voronoi diagram on the surface of a sphere&#34;
        ACM Trans. Math. Softw., Vol. 23, No. 3, pp 416-434
        doi:10.1145/275323.275329

    Args:
        lons : 1D array
            longitudinal coordinates in radians
        lats : 1D array
            latitudinal coordinates in radians
        refinement_levels : int
            refine the number of points in the triangulation
            (see uniformly_refine_triangulation)
        permute : bool
            randomises the order of lons and lats to improve
            triangulation efficiency and eliminate issues where the first points lie on a great circle (see notes)
        tree : bool
            construct a cKDtree for efficient nearest-neighbour lookup

    Attributes:
        lons : array of floats, shape (n,)
            stored longitudinal coordinates on a sphere
        lats : array of floats, shape (n,)
            stored latitudinal coordinates on a sphere
        x : array of floats, shape (n,)
            stored Cartesian x coordinates from input
        y : array of floats, shape (n,)
            stored Cartesian y coordinates from input
        z : array of floats, shape (n,)
            stored Cartesian z coordinates from input
        simplices : array of ints, shape (nsimplex, 3)
            indices of the points forming the simplices in the triangulation
            points are ordered anticlockwise
        lst : array of ints, shape (6n-12,)
            nodal indices with lptr and lend, define the triangulation as a set of N
            adjacency lists; counterclockwise-ordered sequences of neighboring nodes
            such that the first and last neighbors of a boundary node are boundary
            nodes (the first neighbor of an interior node is arbitrary).  In order to
            distinguish between interior and boundary nodes, the last neighbor of
            each boundary node is represented by the negative of its index.
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lptr : array of ints, shape (6n-12),)
            set of pointers in one-to-one correspondence with the elements of lst.
            lst(lptr(i)) indexes the node which follows lst(i) in cyclical
            counterclockwise order (the first neighbor follows the last neighbor).
            The indices are 1-based (as in Fortran), not zero based (as in python).
        lend : array of ints, shape (n,)
            N pointers to adjacency lists.
            lend(k) points to the last neighbor of node K.
            lst(lend(K)) &lt; 0 if and only if K is a boundary node.
            The indices are 1-based (as in Fortran), not zero based (as in python).

    Notes:
        Provided the nodes are randomly ordered, the algorithm
        has expected time complexity O(N*log(N)) for most nodal
        distributions.  Note, however, that the complexity may be
        as high as O(N**2) if, for example, the nodes are ordered
        on increasing latitude.

        if permute=True, lons and lats are randomised on input before
        they are triangulated. The distribution of triangles will
        differ between setting permute=True and permute=False,
        however, the node ordering will remain identical.
    &#34;&#34;&#34;
    def __init__(self, lons, lats, refinement_levels=0, permute=False, tree=False):

        # lons, lats = self._check_integrity(lons, lats)
        self.permute = permute
        self.tree = tree

        self._update_triangulation(lons, lats)

        for r in range(0,refinement_levels):
            lons, lats = self.uniformly_refine_triangulation(faces=False, trisect=False)
            self._update_triangulation(lons,lats)

        return

    def _generate_permutation(self, npoints):
        &#34;&#34;&#34;
        Create shuffle and deshuffle vectors
        &#34;&#34;&#34;
        i = np.arange(0, npoints)
        # permutation
        p = np.random.permutation(npoints)
        ip = np.empty_like(p)
        # inverse permutation
        ip[p[i]] = i
        return p, ip



    def _is_collinear(self, lons, lats):
        &#34;&#34;&#34;
        Checks if first three points are collinear - in the spherical
        case this corresponds to all points lying on a great circle
        and, hence, all coordinate vectors being in a single plane.
        &#34;&#34;&#34;

        x, y, z = lonlat2xyz(lons[:3], lats[:3])
        pts = np.column_stack([x, y, z])

        collinearity = (np.linalg.det(pts.T) == 0.0)

        return collinearity


    def _update_triangulation(self, lons, lats):

        npoints = len(lons)

        # Deal with collinear issue

        if self.permute:
            # Store permutation vectors to shuffle/deshuffle lons and lats
            niter = 0
            ierr = -2
            while ierr==-2 and niter &lt; 5:
                p, ip = self._generate_permutation(npoints)
                lons = lons[p]
                lats = lats[p]
                # compute cartesian coords on unit sphere.
                x, y, z = _stripack.trans(lats, lons)
                lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)
                niter += 1

            if niter &gt;= 5:
                raise ValueError(_ier_codes[-2])
        else:
            p = np.arange(0, npoints)
            ip = p
            # compute cartesian coords on unit sphere.
            x, y, z = _stripack.trans(lats, lons)
            lst, lptr, lend, ierr = _stripack.trmesh(x, y, z)


        self._permutation = p
        self._invpermutation = ip


        if ierr &gt; 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[9999]))
        if ierr != 0:
            raise ValueError(&#39;ierr={} in trmesh\n{}&#39;.format(ierr, _ier_codes[ierr]))

        self.npoints = npoints
        self._lons = lons
        self._lats = lats
        self._x = x
        self._y = y
        self._z = z
        self._points = np.column_stack([x, y, z])
        self.lst = lst
        self.lptr = lptr
        self.lend = lend

        # Convert a triangulation to a triangle list form (human readable)
        # Uses an optimised version of trlist that returns triangles
        # without neighbours or arc indices
        nt, ltri, ierr = _stripack.trlist2(lst, lptr, lend)

        if ierr != 0:
            raise ValueError(&#39;ierr={} in trlist2\n{}&#39;.format(ierr, _ier_codes[ierr]))

        # extract triangle list and convert to zero-based ordering
        self._simplices = ltri.T[:nt] - 1
        ## np.ndarray.sort(self.simplices, axis=1)

        ## If scipy is installed, build a KDtree to find neighbour points

        if self.tree:
            self._build_cKDtree()

    @property
    def lons(self):
        &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lons)
    @property
    def lats(self):
        &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
        return self._deshuffle_field(self._lats)
    @property
    def x(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._x)
    @property
    def y(self):
        &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._y)
    @property
    def z(self):
        &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._z)
    @property
    def points(self):
        &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
        return self._deshuffle_field(self._points)
    @property
    def simplices(self):
        &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
        Points are ordered anticlockwise &#34;&#34;&#34;
        return self._deshuffle_simplices(self._simplices)


    def _shuffle_field(self, *args):
        &#34;&#34;&#34;
        Permute field
        &#34;&#34;&#34;

        p = self._permutation

        fields = []
        for arg in args:
            fields.append( arg[p] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_field(self, *args):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;

        ip = self._invpermutation

        fields = []
        for arg in args:
            fields.append( arg[ip] )

        if len(fields) == 1:
            return fields[0]
        else:
            return fields

    def _deshuffle_simplices(self, simplices):
        &#34;&#34;&#34;
        Return to original ordering
        &#34;&#34;&#34;
        p = self._permutation
        return p[simplices]


    def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the lon / lat components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            data : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdlon : array of floats, shape (n,)
                derivative of f in the longitudinal direction
            dfdlat : array of floats, shape (n,)
                derivative of f in the lattitudinal direction

        Notes:
            The gradient is computed via the Cartesian components using
            `spherical.sTriangulation.gradient_xyz` and the iteration parameters
            controling the spline interpolation are passed directly to this
            routine (See notes for `gradient_xyz` for more details).

            The gradient operator in this geometry is not well defined at the poles
            even if the scalar field is smooth and the Cartesian gradient is well defined.

            The routine spherical.dxyz2dlonlat is available to convert the Cartesian
            to lon/lat coordinates at any point on the unit sphere. This is helpful
            to avoid recalculation if you need both forms.
        &#34;&#34;&#34;

        dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, guarantee_convergence=guarantee_convergence)

        # get deshuffled versions
        lons = self.lons
        lats = self.lats
        z = self.z

        dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
        dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

        corr = np.sqrt((1.0-z**2))
        valid = ~np.isclose(corr,0.0)

        dlon[valid] = dlon[valid] / corr[valid]

        return dlon, dlat


    def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
        &#34;&#34;&#34;
        Return the cartesian components of the gradient
        of a scalar field on the surface of the sphere.

        The method consists of minimizing a quadratic functional Q(G) over
        gradient vectors, where Q is an approximation to the linearized
        curvature over the triangulation of a C-1 bivariate function F(x,y)
        which interpolates the nodal values and gradients.

        Args:
            f : array of floats, shape (n,)
                field over which to evaluate the gradient
            nit : int (default: 3)
                number of iterations to reach a convergence tolerance, tol
                nit &gt;= 1
            tol : float (default: 1e-3)
                maximum change in gradient between iterations.
                convergence is reached when this condition is met.

        Returns:
            dfdx : array of floats, shape (n,)
                derivative of f in the x direction
            dfdy : array of floats, shape (n,)
                derivative of f in the y direction
            dfdz : array of floats, shape (n,)
                derivative of f in the z direction

        Notes:
            For SIGMA = 0, optimal efficiency was achieved in testing with
            tol = 0, and nit = 3 or 4.

            The restriction of F to an arc of the triangulation is taken to be
            the Hermite interpolatory tension spline defined by the data values
            and tangential gradient components at the endpoints of the arc, and
            Q is the sum over the triangulation arcs, excluding interior
            constraint arcs, of the linearized curvatures of F along the arcs --
            the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
            derivative of F with respect to distance T along the arc.
        &#34;&#34;&#34;

        if f.size != self.npoints:
            raise ValueError(&#39;f should be the same size as mesh&#39;)

        # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=np.float32)
        sigma = 0
        iflgs = 0

        f = self._shuffle_field(f)

        ierr = 1
        while ierr == 1:
            grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                                   iflgs, sigma, nit, tol)
            if not guarantee_convergence:
                break

        if ierr &lt; 0:
            warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

        return self._deshuffle_field(grad[0], grad[1], grad[2])


    def smoothing(self, f, w, sm, smtol, gstol):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma = 0
        iflgs = 0
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr



    def _check_integrity(self, lons, lats):
        &#34;&#34;&#34;
        Ensure lons and lats are:
         - 1D numpy arrays
         - equal size
         - within the appropriate range in radians
        &#34;&#34;&#34;

        lons = np.array(lons).ravel()
        lats = np.array(lats).ravel()

        if len(lons.shape) != 1 or len(lats.shape) != 1:
            raise ValueError(&#39;lons and lats must be 1D&#39;)
        if lats.size != lons.size:
            raise ValueError(&#39;lons and lats must have same length&#39;)
        if (np.abs(lons)).max() &gt; 2.*np.pi:
            raise ValueError(&#34;lons must be in radians (-2*pi &lt;= lon &lt;= 2*pi)&#34;)
        if (np.abs(lats)).max() &gt; 0.5*np.pi:
            raise ValueError(&#34;lats must be in radians (-pi/2 &lt;= lat &lt;= pi/2)&#34;)
        return lons, lats





    def interpolate(self, lons, lats, zdata, order=1):
        &#34;&#34;&#34;
        Base class to handle nearest neighbour, linear, and cubic interpolation.
        Given a triangulation of a set of nodes on the unit sphere, along with data
        values at the nodes, this method interpolates (or extrapolates) the value
        at a given longitude and latitude.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere
            zdata : array of floats, shape (n,)
                value at each point in the triangulation
                must be the same size of the mesh
            order : int (default=1)
                order of the interpolatory function used
                    0 = nearest-neighbour
                    1 = linear
                    3 = cubic

        Returns:
            zi : float / array of floats, shape (l,)
                interpolated value(s) at (lons, lats)
            err : int / array of ints, shape (l,)
                whether interpolation (0), extrapolation (1) or error (other)
        &#34;&#34;&#34;


        shape = np.array(lons).shape

        lons, lats = self._check_integrity(lons, lats)

        if order not in [0,1,3]:
            raise ValueError(&#34;order must be 0, 1, or 3&#34;)
        if zdata.size != self.npoints:
            raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

        zdata = self._shuffle_field(zdata)

        zi, zierr, ierr = _stripack.interp_n(order, lats, lons,\
                                      self._x, self._y, self._z, zdata,\
                                      self.lst, self.lptr, self.lend)

        import warnings

        if ierr != 0:
            warnings.warn(&#39;Warning some points may have errors - check error array\n&#39;.format(ierr))
            zi[zierr &lt; 0] = np.nan

        return zi.reshape(shape), zierr.reshape(shape)


    def interpolate_nearest(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using nearest-neighbour approximation
        Returns the same as `interpolate(lons,lats,data,order=0)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=0)

    def interpolate_linear(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using linear approximation
        Returns the same as `interpolate(lons,lats,data,order=1)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=1)

    def interpolate_cubic(self, lons, lats, data):
        &#34;&#34;&#34;
        Interpolate using cubic spline approximation
        Returns the same as `interpolate(lons,lats,data,order=3)`
        &#34;&#34;&#34;
        return self.interpolate(lons, lats, data, order=3)


    def nearest_vertex(self, lons, lats):
        &#34;&#34;&#34;
        Locate the index of the nearest vertex to points (lons,lats)
        and return the squared great circle distance between (lons,lats) and
        each nearest neighbour.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            index : array of ints
                the nearest vertex to each of the supplied points
            dist : array of floats
                great circle distance (angle) on the unit sphere to the closest
                vertex identified.

        Notes:
            Faster searches can be obtained using a k-d tree.
            See `sTriangulation.nearest_vertices()` for details.
            There is an additional overhead associated with building and storing the k-d tree.

        &#34;&#34;&#34;

        # translate to unit sphere

        xi = np.array(_stripack.trans(lats, lons))
        idx = np.empty_like(xi[0,:], dtype=np.int)
        dist = np.empty_like(xi[0,:], dtype=np.float)

        for pt in range(0, xi.shape[1]):
            xi0 = xi[:,pt]

            # i is the node at which we start the search
            # the closest x coordinate is a good place
            i = ((self._x - xi0[0])**2).argmin() + 1

            idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

        idx -= 1 # return to C ordering

        return self._deshuffle_simplices(idx), dist


    def containing_triangle(self, lons, lats):
        &#34;&#34;&#34;
        Returns indices of the triangles containing lons / lats.

        Args:
            lons : float / array of floats, shape (l,)
                longitudinal coordinate(s) on the sphere
            lats : float / array of floats, shape (l,)
                latitudinal coordinate(s) on the sphere

        Returns:
            tri_indices : array of ints, shape (l,)
                indices of containing triangle


        Notes:
            The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

        &#34;&#34;&#34;
        p = self._permutation
        pts = np.array(lonlat2xyz(lons,lats)).T

        sorted_simplices = np.sort(self._simplices, axis=1)

        triangles = []
        for pt in pts:
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri = np.sort(t[3:6]) - 1

            triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

        return np.array(triangles).reshape(-1)


    def containing_simplex_and_bcc(self, lons, lats):
        &#34;&#34;&#34;
        Returns the simplices containing (lons,lats)
        and the local barycentric, normalised coordinates.

        Args:
            lons : float / array of floats, shape(l,)
                longitudinal coordinates in radians
            lats :  float / array of floats, shape(l,)
                latitudinal coordinates in radians

        Returns:
            bcc  : normalised barycentric coordinates
            tri  : simplicies containing (lons,lats)

        Notes:
            That the ordering of the vertices may differ from
            that stored in the self.simplices array but will
            still be a loop around the simplex.
        &#34;&#34;&#34;

        pts = np.array(lonlat2xyz(lons,lats)).T

        tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
        bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

        for i, pt in enumerate(pts):
            t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
            tri[i] = t[3:6]
            bcc[i] = t[0:3]

        tri -= 1 # return to C ordering

        bcc /= bcc.sum(axis=1).reshape(-1,1)

        return bcc, self._deshuffle_simplices(tri)


    def identify_vertex_neighbours(self, vertex):
        &#34;&#34;&#34;
        Find the neighbour-vertices in the triangulation for the given vertex
        (from the data structures of the triangulation)
        &#34;&#34;&#34;
        vertex = self._permutation[vertex]

        lpl = self.lend[vertex-1]
        lp = lpl

        neighbours = []

        while True:
            lp = self.lptr[lp-1]
            neighbours.append(self.lst[lp-1]-1)
            if (lp == lpl):
                break

        return self._deshuffle_simplices(neighbours)


    def identify_vertex_triangles(self, vertices):
        &#34;&#34;&#34;
        Find all triangles which own any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = []

        for vertex in np.array(vertices).reshape(-1):
            triangles.append(np.where(self.simplices == vertex)[0])

        return np.unique(np.concatenate(triangles))



    def identify_segments(self):
        &#34;&#34;&#34;
        Find all the segments in the triangulation and return an
        array of vertices (n1,n2) where n1 &lt; n2
        &#34;&#34;&#34;

        lst  = self.lst
        lend = self.lend
        lptr = self.lptr

        segments_array = np.empty((len(lptr),2),dtype=np.int)
        segments_array[:,0] = lst[:] - 1
        segments_array[:,1] = lst[lptr[:]-1] - 1

        valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
        segments = segments_array[valid,:]

        return self._deshuffle_simplices(segments)


    def segment_midpoints_by_vertices(self, vertices):
        &#34;&#34;&#34;
        Add midpoints to any segment connected to the vertices in the
        list / array provided.
        &#34;&#34;&#34;

        segments = set()

        for vertex in vertices:
            neighbours = self.identify_vertex_neighbours(vertex)
            segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

        segs = np.array(list(segments))

        new_midpoint_lonlats = self.segment_midpoints(segments=segs)

        return new_midpoint_lonlats


    def face_midpoints(self, simplices=None):
        &#34;&#34;&#34;
        Identify the centroid of every simplex in the triangulation. If an array of
        simplices is given then the centroids of only those simplices is returned.
        &#34;&#34;&#34;

        if type(simplices) == type(None):
            simplices = self.simplices

        mids = self.points[simplices].mean(axis=1)
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlons, midlats


    def segment_midpoints(self, segments=None):
        &#34;&#34;&#34;
        Identify the midpoints of every line segment in the triangulation.
        If an array of segments of shape (no_of_segments,2) is given,
        then the midpoints of only those segments is returned. Note,
        segments in the array must not be duplicates or the re-triangulation
        will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
        &#34;&#34;&#34;

        if type(segments) == type(None):
            segments = self.identify_segments()
        points = self.points

        mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
        mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

        lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return lons, lats

    def segment_tripoints(self, ratio=0.33333):
        &#34;&#34;&#34;
        Identify the trisection points of every line segment in the triangulation
        &#34;&#34;&#34;

        segments = self.identify_segments()
        points = self.points

        mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
        mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

        mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
        mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

        mids = np.vstack((mids1,mids2))

        midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

        return midlls


    def lons_map_to_wrapped(self, lon):

        lons = np.array(lon)
        lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

        return lons

    def tri_area(self, lons, lats):
        &#34;&#34;&#34;
        Calculate the area enclosed by 3 points on the unit sphere.

        Args:
            lons : array of floats, shape (3)
                longitudinal coordinates in radians
            lats : array of floats, shape (3)
                latitudinal coordinates in radians

        Returns:
            area : float
                area of triangle on the unit sphere

        &#34;&#34;&#34;
        lons, lats = self._check_integrity(lons, lats)

        # translate to unit sphere
        x, y, z = _stripack.trans(lats, lons)

        # compute area
        area = _stripack.areas(x, y, z)

        return area



    def areas(self):
        &#34;&#34;&#34;
        Compute the area each triangle within the triangulation of points
        on the unit sphere.

        Returns:
            area : array of floats, shape (nt,)
                area of each triangle in self.simplices where nt
                is the number of triangles.

        Notes:
            This uses a Fortran 90 subroutine that wraps the AREA function
            to iterate over many points.
        &#34;&#34;&#34;

        return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)


    def edge_lengths(self):
        &#34;&#34;&#34;
        Compute the edge-lengths of each triangle in the triangulation.
        &#34;&#34;&#34;

        simplex = self.simplices.T

        # simplex is vectors a, b, c defining the corners
        a = self.points[simplex[0]]
        b = self.points[simplex[1]]
        c = self.points[simplex[2]]

        ## dot products to obtain angles
        ab = np.arccos((a * b).sum(axis=1))
        bc = np.arccos((b * c).sum(axis=1))
        ac = np.arccos((a * c).sum(axis=1))

        ## As this is a unit sphere, angle = length so ...

        return ab, bc, ac

    def angular_separation(self, lonp1, latp1, lonp2, latp2):
        &#34;&#34;&#34;
        Compute the angles between lon / lat points p1 and p2 given in radians.
        On the unit sphere, this also corresponds to the great circle distance.
        p1 and p2 can be numpy arrays of the same length.

        This method simply calls the module-level function of the same name.
        Consider using the module function instead, as this method may be
        deprecated in favor of that function. For now, this method is
        retained to avoid issues with the Jupyter notebooks.
        &#34;&#34;&#34;
        # Call the module-level function
        return angular_separation(lonp1, latp1, lonp2, latp2)

    def _add_spherical_midpoints(self):

        midlon_array, midlat_array = self.segment_midpoints()

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_spherical_tripoints(self, ratio=0.333333):

        midlon_array, midlat_array = self.segment_tripoints(ratio=ratio)

        lonv2 = np.concatenate((self.lons, midlon_array), axis=0)
        latv2 = np.concatenate((self.lats, midlat_array), axis=0)

        return lonv2, latv2

    def _add_face_centroids(self):

        facelon_array, facelat_array = self.face_midpoints()

        lonv2 = np.concatenate((self.lons, facelon_array), axis=0)
        latv2 = np.concatenate((self.lats, facelat_array), axis=0)

        return lonv2, latv2


    def uniformly_refine_triangulation(self, faces=False, trisect=False):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation
        &#34;&#34;&#34;

        if faces:
            lonv1, latv1 = self._add_face_centroids()

        else:
            if not trisect:
                lonv1, latv1 = self._add_spherical_midpoints()
            else:
                lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


        return lonv1, latv1


    def midpoint_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1




    def edge_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list
        of indices provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i].`
        &#34;&#34;&#34;

        ## Note there should be no duplicates in the list of triangles
        ## but because we remove duplicates from the list of all segments,
        ## there is no pressing need to check this.

        # identify the segments

        simplices = self.simplices
        segments = set()

        for index in np.array(triangles).reshape(-1):
            tri = simplices[index]
            segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
            segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
            segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

        segs = np.array(list(segments))

        mlons, mlats = self.segment_midpoints(segs)

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def edge_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.edge_refine_triangulation_by_triangles(triangles)



    def centroid_refine_triangulation_by_triangles(self, triangles):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation that are associated with the triangles in the list provided.

        Notes:
            The triangles are here represented as a single index.
            The vertices of triangle `i` are given by `self.simplices[i]`.
        &#34;&#34;&#34;

        # Remove duplicates from the list of triangles

        triangles = np.unique(np.array(triangles))

        mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

        lonv1 = np.concatenate((self.lons, mlons), axis=0)
        latv1 = np.concatenate((self.lats, mlats), axis=0)

        return lonv1, latv1


    def centroid_refine_triangulation_by_vertices(self, vertices):
        &#34;&#34;&#34;
        return points defining a refined triangulation obtained by bisection of all edges
        in the triangulation connected to any of the vertices in the list provided
        &#34;&#34;&#34;

        triangles = self.identify_vertex_triangles(vertices)

        return self.centroid_refine_triangulation_by_triangles(triangles)



    def join(self, t2, unique=False):
        &#34;&#34;&#34;
        Join this triangulation with another. If the points are known to have no duplicates, then
        set unique=True to skip the testing and duplicate removal
        &#34;&#34;&#34;

        lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
        latv1 = np.concatenate((self.lats, t2.lats), axis=0)

        ## remove any duplicates

        if not unique:
            lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

        return lonv1, latv1


    def _build_cKDtree(self):

        try:
            import scipy.spatial
            self._cKDtree =  scipy.spatial.cKDTree(self.points)

        except:
            self._cKDtree = None


    def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
        &#34;&#34;&#34;
        Query the cKDtree for the nearest neighbours and Euclidean
        distance from x,y points.

        Returns 0, 0 if a cKDtree has not been constructed
        (switch `tree=True` if you need this routine)

        Args:
            lon : 1D array
                longitudinal coordinates in radians
            lat : 1D array
                latitudinal coordinates in radians
            k : int (default: 1)
                number of nearest neighbours to return
            max_distance : float (default: 2.0)
                maximum Euclidean distance to search for neighbours

        Returns:
            d : array of floats
                Euclidean distance between each point and their
                nearest neighbour(s)
            vert : array of ints
                vertices of the nearest neighbour(s)
        &#34;&#34;&#34;

        if self.tree == False or self.tree == None:
            return 0, 0

        lons = np.array(lon).reshape(-1,1)
        lats = np.array(lat).reshape(-1,1)

        xyz = np.empty((lons.shape[0],3))
        x,y,z = lonlat2xyz(lons, lats)

        xyz[:,0] = x[:].reshape(-1)
        xyz[:,1] = y[:].reshape(-1)
        xyz[:,2] = z[:].reshape(-1)

        dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


        if k == 1:   # force this to be a 2D array
            vertices = np.reshape(vertices, (-1, 1))

        ## Now find the angular separation / great circle distance: dlatlon


        vertxyz = self.points[vertices].transpose(0,2,1)
        extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

        angles = np.arccos((extxyz * vertxyz).sum(axis=1))

        return angles, vertices</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="stripy.spherical_meshes.icosahedral_mesh" href="spherical_meshes.html#stripy.spherical_meshes.icosahedral_mesh">icosahedral_mesh</a></li>
<li><a title="stripy.spherical_meshes.octahedral_mesh" href="spherical_meshes.html#stripy.spherical_meshes.octahedral_mesh">octahedral_mesh</a></li>
<li><a title="stripy.spherical_meshes.random_mesh" href="spherical_meshes.html#stripy.spherical_meshes.random_mesh">random_mesh</a></li>
<li><a title="stripy.spherical_meshes.triangulated_cube_mesh" href="spherical_meshes.html#stripy.spherical_meshes.triangulated_cube_mesh">triangulated_cube_mesh</a></li>
<li><a title="stripy.spherical_meshes.triangulated_soccerball_mesh" href="spherical_meshes.html#stripy.spherical_meshes.triangulated_soccerball_mesh">triangulated_soccerball_mesh</a></li>
<li><a title="stripy.spherical_meshes.uniform_ring_mesh" href="spherical_meshes.html#stripy.spherical_meshes.uniform_ring_mesh">uniform_ring_mesh</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="stripy.spherical.sTriangulation.lats"><code class="name">var <span class="ident">lats</span></code></dt>
<dd>
<section class="desc"><p>Latitudinal coordinates on a sphere</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lats(self):
    &#34;&#34;&#34; Latitudinal coordinates on a sphere &#34;&#34;&#34;
    return self._deshuffle_field(self._lats)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.lons"><code class="name">var <span class="ident">lons</span></code></dt>
<dd>
<section class="desc"><p>Longitudinal coordinates on a sphere</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lons(self):
    &#34;&#34;&#34; Longitudinal coordinates on a sphere &#34;&#34;&#34;
    return self._deshuffle_field(self._lons)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.points"><code class="name">var <span class="ident">points</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian xyz coordinates from triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def points(self):
    &#34;&#34;&#34; Stored Cartesian xyz coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._points)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.simplices"><code class="name">var <span class="ident">simplices</span></code></dt>
<dd>
<section class="desc"><p>Indices of the points forming the simplices in the triangulation.
Points are ordered anticlockwise</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def simplices(self):
    &#34;&#34;&#34; Indices of the points forming the simplices in the triangulation.
    Points are ordered anticlockwise &#34;&#34;&#34;
    return self._deshuffle_simplices(self._simplices)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian x coordinates from triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x(self):
    &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._x)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian y coordinates from triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y(self):
    &#34;&#34;&#34; Stored Cartesian y coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._y)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.z"><code class="name">var <span class="ident">z</span></code></dt>
<dd>
<section class="desc"><p>Stored Cartesian x coordinates from triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def z(self):
    &#34;&#34;&#34; Stored Cartesian x coordinates from triangulation &#34;&#34;&#34;
    return self._deshuffle_field(self._z)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="stripy.spherical.sTriangulation.angular_separation"><code class="name flex">
<span>def <span class="ident">angular_separation</span></span>(<span>self, lonp1, latp1, lonp2, latp2)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the angles between lon / lat points p1 and p2 given in radians.
On the unit sphere, this also corresponds to the great circle distance.
p1 and p2 can be numpy arrays of the same length.</p>
<p>This method simply calls the module-level function of the same name.
Consider using the module function instead, as this method may be
deprecated in favor of that function. For now, this method is
retained to avoid issues with the Jupyter notebooks.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def angular_separation(self, lonp1, latp1, lonp2, latp2):
    &#34;&#34;&#34;
    Compute the angles between lon / lat points p1 and p2 given in radians.
    On the unit sphere, this also corresponds to the great circle distance.
    p1 and p2 can be numpy arrays of the same length.

    This method simply calls the module-level function of the same name.
    Consider using the module function instead, as this method may be
    deprecated in favor of that function. For now, this method is
    retained to avoid issues with the Jupyter notebooks.
    &#34;&#34;&#34;
    # Call the module-level function
    return angular_separation(lonp1, latp1, lonp2, latp2)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.areas"><code class="name flex">
<span>def <span class="ident">areas</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the area each triangle within the triangulation of points
on the unit sphere.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>nt</code>,)</dt>
<dd>area of each triangle in self.simplices where nt
is the number of triangles.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This uses a Fortran 90 subroutine that wraps the AREA function
to iterate over many points.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def areas(self):
    &#34;&#34;&#34;
    Compute the area each triangle within the triangulation of points
    on the unit sphere.

    Returns:
        area : array of floats, shape (nt,)
            area of each triangle in self.simplices where nt
            is the number of triangles.

    Notes:
        This uses a Fortran 90 subroutine that wraps the AREA function
        to iterate over many points.
    &#34;&#34;&#34;

    return _stripack.triareas(self.x, self.y, self.z, self.simplices.T+1)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation that are associated with the triangles in the list provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i]</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroid_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation that are associated with the triangles in the list provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i]`.
    &#34;&#34;&#34;

    # Remove duplicates from the list of triangles

    triangles = np.unique(np.array(triangles))

    mlons, mlats = self.face_midpoints(simplices=self.simplices[triangles])

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">centroid_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centroid_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.centroid_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.containing_simplex_and_bcc"><code class="name flex">
<span>def <span class="ident">containing_simplex_and_bcc</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the simplices containing (lons,lats)
and the local barycentric, normalised coordinates.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code>(<code>l</code>,)</dt>
<dd>longitudinal coordinates in radians</dd>
<dt><strong><code>lats</code></strong> :&ensp; <code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code>(<code>l</code>,)</dt>
<dd>latitudinal coordinates in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bcc</code>
: <code>normalised</code> <code>barycentric</code> <code>coordinates</code></dt>
<dd>&nbsp;</dd>
<dt><code>tri</code>
: <code>simplicies</code> <code>containing</code> (<code>lons</code>,<code>lats</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>That the ordering of the vertices may differ from
that stored in the self.simplices array but will
still be a loop around the simplex.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containing_simplex_and_bcc(self, lons, lats):
    &#34;&#34;&#34;
    Returns the simplices containing (lons,lats)
    and the local barycentric, normalised coordinates.

    Args:
        lons : float / array of floats, shape(l,)
            longitudinal coordinates in radians
        lats :  float / array of floats, shape(l,)
            latitudinal coordinates in radians

    Returns:
        bcc  : normalised barycentric coordinates
        tri  : simplicies containing (lons,lats)

    Notes:
        That the ordering of the vertices may differ from
        that stored in the self.simplices array but will
        still be a loop around the simplex.
    &#34;&#34;&#34;

    pts = np.array(lonlat2xyz(lons,lats)).T

    tri = np.empty((pts.shape[0], 3), dtype=np.int) # simplices
    bcc = np.empty_like(tri, dtype=np.float) # barycentric coords

    for i, pt in enumerate(pts):
        t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
        tri[i] = t[3:6]
        bcc[i] = t[0:3]

    tri -= 1 # return to C ordering

    bcc /= bcc.sum(axis=1).reshape(-1,1)

    return bcc, self._deshuffle_simplices(tri)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.containing_triangle"><code class="name flex">
<span>def <span class="ident">containing_triangle</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns indices of the triangles containing lons / lats.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>longitudinal coordinate(s) on the sphere</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>latitudinal coordinate(s) on the sphere</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>tri_indices</code></strong> :&ensp;<code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>indices of containing triangle</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The simplices are found as <code>spherical.sTriangulation.simplices[tri_indices]</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def containing_triangle(self, lons, lats):
    &#34;&#34;&#34;
    Returns indices of the triangles containing lons / lats.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere

    Returns:
        tri_indices : array of ints, shape (l,)
            indices of containing triangle


    Notes:
        The simplices are found as `spherical.sTriangulation.simplices[tri_indices]`

    &#34;&#34;&#34;
    p = self._permutation
    pts = np.array(lonlat2xyz(lons,lats)).T

    sorted_simplices = np.sort(self._simplices, axis=1)

    triangles = []
    for pt in pts:
        t = _stripack.trfind(3, pt, self._x, self._y, self._z, self.lst, self.lptr, self.lend )
        tri = np.sort(t[3:6]) - 1

        triangles.append(np.where(np.all(p[sorted_simplices]==p[tri], axis=1))[0])

    return np.array(triangles).reshape(-1)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_lengths"><code class="name flex">
<span>def <span class="ident">edge_lengths</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute the edge-lengths of each triangle in the triangulation.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_lengths(self):
    &#34;&#34;&#34;
    Compute the edge-lengths of each triangle in the triangulation.
    &#34;&#34;&#34;

    simplex = self.simplices.T

    # simplex is vectors a, b, c defining the corners
    a = self.points[simplex[0]]
    b = self.points[simplex[1]]
    c = self.points[simplex[2]]

    ## dot products to obtain angles
    ab = np.arccos((a * b).sum(axis=1))
    bc = np.arccos((b * c).sum(axis=1))
    ac = np.arccos((a * c).sum(axis=1))

    ## As this is a unit sphere, angle = length so ...

    return ab, bc, ac</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_triangles</span></span>(<span>self, triangles)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation that are associated with the triangles in the list
of indices provided.</p>
<h2 id="notes">Notes</h2>
<p>The triangles are here represented as a single index.
The vertices of triangle <code>i</code> are given by <code>self.simplices[i].</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_refine_triangulation_by_triangles(self, triangles):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation that are associated with the triangles in the list
    of indices provided.

    Notes:
        The triangles are here represented as a single index.
        The vertices of triangle `i` are given by `self.simplices[i].`
    &#34;&#34;&#34;

    ## Note there should be no duplicates in the list of triangles
    ## but because we remove duplicates from the list of all segments,
    ## there is no pressing need to check this.

    # identify the segments

    simplices = self.simplices
    segments = set()

    for index in np.array(triangles).reshape(-1):
        tri = simplices[index]
        segments.add( min( tuple((tri[0], tri[1])), tuple((tri[1], tri[0]))) )
        segments.add( min( tuple((tri[1], tri[2])), tuple((tri[2], tri[1]))) )
        segments.add( min( tuple((tri[0], tri[2])), tuple((tri[2], tri[0]))) )

    segs = np.array(list(segments))

    mlons, mlats = self.segment_midpoints(segs)

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">edge_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edge_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = self.identify_vertex_triangles(vertices)

    return self.edge_refine_triangulation_by_triangles(triangles)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.face_midpoints"><code class="name flex">
<span>def <span class="ident">face_midpoints</span></span>(<span>self, simplices=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the centroid of every simplex in the triangulation. If an array of
simplices is given then the centroids of only those simplices is returned.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def face_midpoints(self, simplices=None):
    &#34;&#34;&#34;
    Identify the centroid of every simplex in the triangulation. If an array of
    simplices is given then the centroids of only those simplices is returned.
    &#34;&#34;&#34;

    if type(simplices) == type(None):
        simplices = self.simplices

    mids = self.points[simplices].mean(axis=1)
    mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

    midlons, midlats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return midlons, midlats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.gradient_lonlat"><code class="name flex">
<span>def <span class="ident">gradient_lonlat</span></span>(<span>self, data, nit=3, tol=0.001, guarantee_convergence=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the lon / lat components of the gradient
of a scalar field on the surface of the sphere.</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors, where Q is an approximation to the linearized
curvature over the triangulation of a C-1 bivariate function F(x,y)
which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>field over which to evaluate the gradient</dd>
<dt><strong><code>nit</code></strong> :&ensp;<code>int</code> (default: <code>3</code>)</dt>
<dd>number of iterations to reach a convergence tolerance, tol
nit &gt;= 1</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code> (default: <code>1e</code>-<code>3</code>)</dt>
<dd>maximum change in gradient between iterations.
convergence is reached when this condition is met.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dfdlon</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the longitudinal direction</dd>
<dt><strong><code>dfdlat</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the lattitudinal direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The gradient is computed via the Cartesian components using
<code>spherical.sTriangulation.gradient_xyz</code> and the iteration parameters
controling the spline interpolation are passed directly to this
routine (See notes for <code>gradient_xyz</code> for more details).</p>
<p>The gradient operator in this geometry is not well defined at the poles
even if the scalar field is smooth and the Cartesian gradient is well defined.</p>
<p>The routine spherical.dxyz2dlonlat is available to convert the Cartesian
to lon/lat coordinates at any point on the unit sphere. This is helpful
to avoid recalculation if you need both forms.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_lonlat(self, data, nit=3, tol=1.0e-3, guarantee_convergence=False):
    &#34;&#34;&#34;
    Return the lon / lat components of the gradient
    of a scalar field on the surface of the sphere.

    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors, where Q is an approximation to the linearized
    curvature over the triangulation of a C-1 bivariate function F(x,y)
    which interpolates the nodal values and gradients.

    Args:
        data : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance, tol
            nit &gt;= 1
        tol : float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.

    Returns:
        dfdlon : array of floats, shape (n,)
            derivative of f in the longitudinal direction
        dfdlat : array of floats, shape (n,)
            derivative of f in the lattitudinal direction

    Notes:
        The gradient is computed via the Cartesian components using
        `spherical.sTriangulation.gradient_xyz` and the iteration parameters
        controling the spline interpolation are passed directly to this
        routine (See notes for `gradient_xyz` for more details).

        The gradient operator in this geometry is not well defined at the poles
        even if the scalar field is smooth and the Cartesian gradient is well defined.

        The routine spherical.dxyz2dlonlat is available to convert the Cartesian
        to lon/lat coordinates at any point on the unit sphere. This is helpful
        to avoid recalculation if you need both forms.
    &#34;&#34;&#34;

    dfxs, dfys, dfzs = self.gradient_xyz(data, nit=nit, tol=tol, guarantee_convergence=guarantee_convergence)

    # get deshuffled versions
    lons = self.lons
    lats = self.lats
    z = self.z

    dlon = -dfxs * np.cos(lats) * np.sin(lons) + dfys * np.cos(lats) * np.cos(lons) # no z dependence
    dlat = -dfxs * np.sin(lats) * np.cos(lons) - dfys * np.sin(lats) * np.sin(lons) + dfzs * np.cos(lats)

    corr = np.sqrt((1.0-z**2))
    valid = ~np.isclose(corr,0.0)

    dlon[valid] = dlon[valid] / corr[valid]

    return dlon, dlat</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.gradient_xyz"><code class="name flex">
<span>def <span class="ident">gradient_xyz</span></span>(<span>self, f, nit=3, tol=0.001, guarantee_convergence=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the cartesian components of the gradient
of a scalar field on the surface of the sphere.</p>
<p>The method consists of minimizing a quadratic functional Q(G) over
gradient vectors, where Q is an approximation to the linearized
curvature over the triangulation of a C-1 bivariate function F(x,y)
which interpolates the nodal values and gradients.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>field over which to evaluate the gradient</dd>
<dt><strong><code>nit</code></strong> :&ensp;<code>int</code> (default: <code>3</code>)</dt>
<dd>number of iterations to reach a convergence tolerance, tol
nit &gt;= 1</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code> (default: <code>1e</code>-<code>3</code>)</dt>
<dd>maximum change in gradient between iterations.
convergence is reached when this condition is met.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dfdx</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the x direction</dd>
<dt><strong><code>dfdy</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the y direction</dd>
<dt><strong><code>dfdz</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>derivative of f in the z direction</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>For SIGMA = 0, optimal efficiency was achieved in testing with
tol = 0, and nit = 3 or 4.</p>
<p>The restriction of F to an arc of the triangulation is taken to be
the Hermite interpolatory tension spline defined by the data values
and tangential gradient components at the endpoints of the arc, and
Q is the sum over the triangulation arcs, excluding interior
constraint arcs, of the linearized curvatures of F along the arcs &ndash;
the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
derivative of F with respect to distance T along the arc.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gradient_xyz(self, f, nit=3, tol=1e-3, guarantee_convergence=False):
    &#34;&#34;&#34;
    Return the cartesian components of the gradient
    of a scalar field on the surface of the sphere.

    The method consists of minimizing a quadratic functional Q(G) over
    gradient vectors, where Q is an approximation to the linearized
    curvature over the triangulation of a C-1 bivariate function F(x,y)
    which interpolates the nodal values and gradients.

    Args:
        f : array of floats, shape (n,)
            field over which to evaluate the gradient
        nit : int (default: 3)
            number of iterations to reach a convergence tolerance, tol
            nit &gt;= 1
        tol : float (default: 1e-3)
            maximum change in gradient between iterations.
            convergence is reached when this condition is met.

    Returns:
        dfdx : array of floats, shape (n,)
            derivative of f in the x direction
        dfdy : array of floats, shape (n,)
            derivative of f in the y direction
        dfdz : array of floats, shape (n,)
            derivative of f in the z direction

    Notes:
        For SIGMA = 0, optimal efficiency was achieved in testing with
        tol = 0, and nit = 3 or 4.

        The restriction of F to an arc of the triangulation is taken to be
        the Hermite interpolatory tension spline defined by the data values
        and tangential gradient components at the endpoints of the arc, and
        Q is the sum over the triangulation arcs, excluding interior
        constraint arcs, of the linearized curvatures of F along the arcs --
        the integrals over the arcs of D2F(T)**2, where D2F(T) is the second
        derivative of F with respect to distance T along the arc.
    &#34;&#34;&#34;

    if f.size != self.npoints:
        raise ValueError(&#39;f should be the same size as mesh&#39;)

    # gradient = np.zeros((3,self.npoints), order=&#39;F&#39;, dtype=np.float32)
    sigma = 0
    iflgs = 0

    f = self._shuffle_field(f)

    ierr = 1
    while ierr == 1:
        grad, ierr = _ssrfpack.gradg(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                               iflgs, sigma, nit, tol)
        if not guarantee_convergence:
            break

    if ierr &lt; 0:
        warnings.warn(&#39;ierr={} in gradg\n{}&#39;.format(ierr, _ier_codes[ierr]))

    return self._deshuffle_field(grad[0], grad[1], grad[2])</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_segments"><code class="name flex">
<span>def <span class="ident">identify_segments</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Find all the segments in the triangulation and return an
array of vertices (n1,n2) where n1 &lt; n2</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_segments(self):
    &#34;&#34;&#34;
    Find all the segments in the triangulation and return an
    array of vertices (n1,n2) where n1 &lt; n2
    &#34;&#34;&#34;

    lst  = self.lst
    lend = self.lend
    lptr = self.lptr

    segments_array = np.empty((len(lptr),2),dtype=np.int)
    segments_array[:,0] = lst[:] - 1
    segments_array[:,1] = lst[lptr[:]-1] - 1

    valid = np.where(segments_array[:,0] &lt; segments_array[:,1])[0]
    segments = segments_array[valid,:]

    return self._deshuffle_simplices(segments)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_vertex_neighbours"><code class="name flex">
<span>def <span class="ident">identify_vertex_neighbours</span></span>(<span>self, vertex)</span>
</code></dt>
<dd>
<section class="desc"><p>Find the neighbour-vertices in the triangulation for the given vertex
(from the data structures of the triangulation)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_vertex_neighbours(self, vertex):
    &#34;&#34;&#34;
    Find the neighbour-vertices in the triangulation for the given vertex
    (from the data structures of the triangulation)
    &#34;&#34;&#34;
    vertex = self._permutation[vertex]

    lpl = self.lend[vertex-1]
    lp = lpl

    neighbours = []

    while True:
        lp = self.lptr[lp-1]
        neighbours.append(self.lst[lp-1]-1)
        if (lp == lpl):
            break

    return self._deshuffle_simplices(neighbours)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.identify_vertex_triangles"><code class="name flex">
<span>def <span class="ident">identify_vertex_triangles</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Find all triangles which own any of the vertices in the list provided</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify_vertex_triangles(self, vertices):
    &#34;&#34;&#34;
    Find all triangles which own any of the vertices in the list provided
    &#34;&#34;&#34;

    triangles = []

    for vertex in np.array(vertices).reshape(-1):
        triangles.append(np.where(self.simplices == vertex)[0])

    return np.unique(np.concatenate(triangles))</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, lons, lats, zdata, order=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class to handle nearest neighbour, linear, and cubic interpolation.
Given a triangulation of a set of nodes on the unit sphere, along with data
values at the nodes, this method interpolates (or extrapolates) the value
at a given longitude and latitude.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>longitudinal coordinate(s) on the sphere</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>latitudinal coordinate(s) on the sphere</dd>
<dt><strong><code>zdata</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>value at each point in the triangulation
must be the same size of the mesh</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code> (default=<code>1</code>)</dt>
<dd>order of the interpolatory function used
0 = nearest-neighbour
1 = linear
3 = cubic</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>zi</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>interpolated value(s) at (lons, lats)</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>int</code> / <code>array</code> of <code>ints</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>whether interpolation (0), extrapolation (1) or error (other)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(self, lons, lats, zdata, order=1):
    &#34;&#34;&#34;
    Base class to handle nearest neighbour, linear, and cubic interpolation.
    Given a triangulation of a set of nodes on the unit sphere, along with data
    values at the nodes, this method interpolates (or extrapolates) the value
    at a given longitude and latitude.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere
        zdata : array of floats, shape (n,)
            value at each point in the triangulation
            must be the same size of the mesh
        order : int (default=1)
            order of the interpolatory function used
                0 = nearest-neighbour
                1 = linear
                3 = cubic

    Returns:
        zi : float / array of floats, shape (l,)
            interpolated value(s) at (lons, lats)
        err : int / array of ints, shape (l,)
            whether interpolation (0), extrapolation (1) or error (other)
    &#34;&#34;&#34;


    shape = np.array(lons).shape

    lons, lats = self._check_integrity(lons, lats)

    if order not in [0,1,3]:
        raise ValueError(&#34;order must be 0, 1, or 3&#34;)
    if zdata.size != self.npoints:
        raise ValueError(&#34;data must be of size {}&#34;.format(self.npoints))

    zdata = self._shuffle_field(zdata)

    zi, zierr, ierr = _stripack.interp_n(order, lats, lons,\
                                  self._x, self._y, self._z, zdata,\
                                  self.lst, self.lptr, self.lend)

    import warnings

    if ierr != 0:
        warnings.warn(&#39;Warning some points may have errors - check error array\n&#39;.format(ierr))
        zi[zierr &lt; 0] = np.nan

    return zi.reshape(shape), zierr.reshape(shape)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_cubic"><code class="name flex">
<span>def <span class="ident">interpolate_cubic</span></span>(<span>self, lons, lats, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Interpolate using cubic spline approximation
Returns the same as <code>interpolate(lons,lats,data,order=3)</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_cubic(self, lons, lats, data):
    &#34;&#34;&#34;
    Interpolate using cubic spline approximation
    Returns the same as `interpolate(lons,lats,data,order=3)`
    &#34;&#34;&#34;
    return self.interpolate(lons, lats, data, order=3)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_linear"><code class="name flex">
<span>def <span class="ident">interpolate_linear</span></span>(<span>self, lons, lats, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Interpolate using linear approximation
Returns the same as <code>interpolate(lons,lats,data,order=1)</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_linear(self, lons, lats, data):
    &#34;&#34;&#34;
    Interpolate using linear approximation
    Returns the same as `interpolate(lons,lats,data,order=1)`
    &#34;&#34;&#34;
    return self.interpolate(lons, lats, data, order=1)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.interpolate_nearest"><code class="name flex">
<span>def <span class="ident">interpolate_nearest</span></span>(<span>self, lons, lats, data)</span>
</code></dt>
<dd>
<section class="desc"><p>Interpolate using nearest-neighbour approximation
Returns the same as <code>interpolate(lons,lats,data,order=0)</code></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_nearest(self, lons, lats, data):
    &#34;&#34;&#34;
    Interpolate using nearest-neighbour approximation
    Returns the same as `interpolate(lons,lats,data,order=0)`
    &#34;&#34;&#34;
    return self.interpolate(lons, lats, data, order=0)</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, t2, unique=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Join this triangulation with another. If the points are known to have no duplicates, then
set unique=True to skip the testing and duplicate removal</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, t2, unique=False):
    &#34;&#34;&#34;
    Join this triangulation with another. If the points are known to have no duplicates, then
    set unique=True to skip the testing and duplicate removal
    &#34;&#34;&#34;

    lonv1 = np.concatenate((self.lons, t2.lons), axis=0)
    latv1 = np.concatenate((self.lats, t2.lats), axis=0)

    ## remove any duplicates

    if not unique:
        lonv1, latv1 = remove_duplicate_lonlat(lonv1, latv1)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.lons_map_to_wrapped"><code class="name flex">
<span>def <span class="ident">lons_map_to_wrapped</span></span>(<span>self, lon)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lons_map_to_wrapped(self, lon):

    lons = np.array(lon)
    lons = np.mod(lon+np.pi, 2*np.pi) - np.pi

    return lons</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices"><code class="name flex">
<span>def <span class="ident">midpoint_refine_triangulation_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation connected to any of the vertices in the list provided</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def midpoint_refine_triangulation_by_vertices(self, vertices):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation connected to any of the vertices in the list provided
    &#34;&#34;&#34;

    mlons, mlats = self.segment_midpoints_by_vertices(vertices=vertices)

    lonv1 = np.concatenate((self.lons, mlons), axis=0)
    latv1 = np.concatenate((self.lats, mlats), axis=0)

    return lonv1, latv1</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.nearest_vertex"><code class="name flex">
<span>def <span class="ident">nearest_vertex</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<section class="desc"><p>Locate the index of the nearest vertex to points (lons,lats)
and return the squared great circle distance between (lons,lats) and
each nearest neighbour.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>longitudinal coordinate(s) on the sphere</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>float</code> / <code>array</code> of <code>floats</code>, <code>shape</code> (<code>l</code>,)</dt>
<dd>latitudinal coordinate(s) on the sphere</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>index</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>the nearest vertex to each of the supplied points</dd>
<dt><strong><code>dist</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>great circle distance (angle) on the unit sphere to the closest
vertex identified.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Faster searches can be obtained using a k-d tree.
See <a title="stripy.spherical.sTriangulation.nearest_vertices" href="#stripy.spherical.sTriangulation.nearest_vertices"><code>sTriangulation.nearest_vertices()</code></a> for details.
There is an additional overhead associated with building and storing the k-d tree.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_vertex(self, lons, lats):
    &#34;&#34;&#34;
    Locate the index of the nearest vertex to points (lons,lats)
    and return the squared great circle distance between (lons,lats) and
    each nearest neighbour.

    Args:
        lons : float / array of floats, shape (l,)
            longitudinal coordinate(s) on the sphere
        lats : float / array of floats, shape (l,)
            latitudinal coordinate(s) on the sphere

    Returns:
        index : array of ints
            the nearest vertex to each of the supplied points
        dist : array of floats
            great circle distance (angle) on the unit sphere to the closest
            vertex identified.

    Notes:
        Faster searches can be obtained using a k-d tree.
        See `sTriangulation.nearest_vertices()` for details.
        There is an additional overhead associated with building and storing the k-d tree.

    &#34;&#34;&#34;

    # translate to unit sphere

    xi = np.array(_stripack.trans(lats, lons))
    idx = np.empty_like(xi[0,:], dtype=np.int)
    dist = np.empty_like(xi[0,:], dtype=np.float)

    for pt in range(0, xi.shape[1]):
        xi0 = xi[:,pt]

        # i is the node at which we start the search
        # the closest x coordinate is a good place
        i = ((self._x - xi0[0])**2).argmin() + 1

        idx[pt], dist[pt] = _stripack.nearnd((xi0[0],xi0[1],xi0[2]), self._x, self._y, self._z, self.lst, self.lptr, self.lend, i)

    idx -= 1 # return to C ordering

    return self._deshuffle_simplices(idx), dist</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.nearest_vertices"><code class="name flex">
<span>def <span class="ident">nearest_vertices</span></span>(<span>self, lon, lat, k=1, max_distance=2.0)</span>
</code></dt>
<dd>
<section class="desc"><p>Query the cKDtree for the nearest neighbours and Euclidean
distance from x,y points.</p>
<p>Returns 0, 0 if a cKDtree has not been constructed
(switch <code>tree=True</code> if you need this routine)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lon</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>longitudinal coordinates in radians</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>1D</code> <code>array</code></dt>
<dd>latitudinal coordinates in radians</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>int</code> (default: <code>1</code>)</dt>
<dd>number of nearest neighbours to return</dd>
<dt><strong><code>max_distance</code></strong> :&ensp;<code>float</code> (default: <code>2.0</code>)</dt>
<dd>maximum Euclidean distance to search for neighbours</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>array</code> of <code>floats</code></dt>
<dd>Euclidean distance between each point and their
nearest neighbour(s)</dd>
<dt><strong><code>vert</code></strong> :&ensp;<code>array</code> of <code>ints</code></dt>
<dd>vertices of the nearest neighbour(s)</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_vertices(self, lon, lat, k=1, max_distance=2.0 ):
    &#34;&#34;&#34;
    Query the cKDtree for the nearest neighbours and Euclidean
    distance from x,y points.

    Returns 0, 0 if a cKDtree has not been constructed
    (switch `tree=True` if you need this routine)

    Args:
        lon : 1D array
            longitudinal coordinates in radians
        lat : 1D array
            latitudinal coordinates in radians
        k : int (default: 1)
            number of nearest neighbours to return
        max_distance : float (default: 2.0)
            maximum Euclidean distance to search for neighbours

    Returns:
        d : array of floats
            Euclidean distance between each point and their
            nearest neighbour(s)
        vert : array of ints
            vertices of the nearest neighbour(s)
    &#34;&#34;&#34;

    if self.tree == False or self.tree == None:
        return 0, 0

    lons = np.array(lon).reshape(-1,1)
    lats = np.array(lat).reshape(-1,1)

    xyz = np.empty((lons.shape[0],3))
    x,y,z = lonlat2xyz(lons, lats)

    xyz[:,0] = x[:].reshape(-1)
    xyz[:,1] = y[:].reshape(-1)
    xyz[:,2] = z[:].reshape(-1)

    dxyz, vertices = self._cKDtree.query(xyz, k=k, distance_upper_bound=max_distance)


    if k == 1:   # force this to be a 2D array
        vertices = np.reshape(vertices, (-1, 1))

    ## Now find the angular separation / great circle distance: dlatlon


    vertxyz = self.points[vertices].transpose(0,2,1)
    extxyz  = np.repeat(xyz, k, axis=1).reshape(vertxyz.shape)

    angles = np.arccos((extxyz * vertxyz).sum(axis=1))

    return angles, vertices</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_midpoints"><code class="name flex">
<span>def <span class="ident">segment_midpoints</span></span>(<span>self, segments=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the midpoints of every line segment in the triangulation.
If an array of segments of shape (no_of_segments,2) is given,
then the midpoints of only those segments is returned. Note,
segments in the array must not be duplicates or the re-triangulation
will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_midpoints(self, segments=None):
    &#34;&#34;&#34;
    Identify the midpoints of every line segment in the triangulation.
    If an array of segments of shape (no_of_segments,2) is given,
    then the midpoints of only those segments is returned. Note,
    segments in the array must not be duplicates or the re-triangulation
    will fail. Take care not to miss that (n1,n2) is equivalent to (n2,n1).
    &#34;&#34;&#34;

    if type(segments) == type(None):
        segments = self.identify_segments()
    points = self.points

    mids = (points[segments[:,0]] + points[segments[:,1]]) * 0.5
    mids /= np.linalg.norm(mids, axis=1).reshape(-1,1)

    lons, lats = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return lons, lats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_midpoints_by_vertices"><code class="name flex">
<span>def <span class="ident">segment_midpoints_by_vertices</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Add midpoints to any segment connected to the vertices in the
list / array provided.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_midpoints_by_vertices(self, vertices):
    &#34;&#34;&#34;
    Add midpoints to any segment connected to the vertices in the
    list / array provided.
    &#34;&#34;&#34;

    segments = set()

    for vertex in vertices:
        neighbours = self.identify_vertex_neighbours(vertex)
        segments.update( min( tuple((vertex, n1)), tuple((n1, vertex))) for n1 in neighbours )

    segs = np.array(list(segments))

    new_midpoint_lonlats = self.segment_midpoints(segments=segs)

    return new_midpoint_lonlats</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.segment_tripoints"><code class="name flex">
<span>def <span class="ident">segment_tripoints</span></span>(<span>self, ratio=0.33333)</span>
</code></dt>
<dd>
<section class="desc"><p>Identify the trisection points of every line segment in the triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def segment_tripoints(self, ratio=0.33333):
    &#34;&#34;&#34;
    Identify the trisection points of every line segment in the triangulation
    &#34;&#34;&#34;

    segments = self.identify_segments()
    points = self.points

    mids1 = ratio * points[segments[:,0]] + (1.0-ratio) * points[segments[:,1]]
    mids1 /= np.linalg.norm(mids1, axis=1).reshape(-1,1)

    mids2 = (1.0-ratio) *  points[segments[:,0]] + ratio * points[segments[:,1]]
    mids2 /= np.linalg.norm(mids2, axis=1).reshape(-1,1)

    mids = np.vstack((mids1,mids2))

    midlls = xyz2lonlat(mids[:,0], mids[:,1], mids[:,2])

    return midlls</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.smoothing"><code class="name flex">
<span>def <span class="ident">smoothing</span></span>(<span>self, f, w, sm, smtol, gstol)</span>
</code></dt>
<dd>
<section class="desc"><p>Smooths a surface f by choosing nodal function values and gradients to
minimize the linearized curvature of F subject to a bound on the
deviation from the data values. This is more appropriate than interpolation
when significant errors are present in the data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>field to apply smoothing on</dd>
<dt><strong><code>w</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>weights associated with data value in f
w[i] = 1/sigma_f^2 is a good rule of thumb.</dd>
<dt><strong><code>sm</code></strong> :&ensp;<code>float</code></dt>
<dd>positive parameter specifying an upper bound on Q2(f).
generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)</dd>
<dt><strong><code>smtol</code></strong> :&ensp;<code>float</code></dt>
<dd>specifies relative error in satisfying the constraint
sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.</dd>
<dt><strong><code>gstol</code></strong> :&ensp;<code>float</code></dt>
<dd>tolerance for convergence.
gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>f_smooth</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,)</dt>
<dd>smoothed version of f</dd>
<dt><strong><code>derivatives</code></strong> :&ensp;<code>tuple</code> of <code>floats</code>, <code>shape</code> (<code>n</code>,<code>3</code>)</dt>
<dd>(dfdx, dfdy, dfdz) first derivatives of f_smooth in the
x, y, and z directions</dd>
<dt><strong><code>err</code></strong> :&ensp;<code>error</code> <code>indicator</code></dt>
<dd>0 indicates no error, +ve values indicate warnings, -ve values are errors</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def smoothing(self, f, w, sm, smtol, gstol):
        &#34;&#34;&#34;
        Smooths a surface f by choosing nodal function values and gradients to
        minimize the linearized curvature of F subject to a bound on the
        deviation from the data values. This is more appropriate than interpolation
        when significant errors are present in the data.

        Args:
            f : array of floats, shape (n,)
                field to apply smoothing on
            w : array of floats, shape (n,)
                weights associated with data value in f
                w[i] = 1/sigma_f^2 is a good rule of thumb.
            sm : float
                positive parameter specifying an upper bound on Q2(f).
                generally n-sqrt(2n) &lt;= sm &lt;= n+sqrt(2n)
            smtol : float
                specifies relative error in satisfying the constraint
                sm(1-smtol) &lt;= Q2 &lt;= sm(1+smtol) between 0 and 1.
            gstol : float
                tolerance for convergence.
                gstol = 0.05*mean(sigma_f)^2 is a good rule of thumb.

        Returns:
            f_smooth : array of floats, shape (n,)
                smoothed version of f
            derivatives : tuple of floats, shape (n,3)
                (dfdx, dfdy, dfdz) first derivatives of f_smooth in the
                x, y, and z directions
            err : error indicator
                0 indicates no error, +ve values indicate warnings, -ve values are errors
        &#34;&#34;&#34;

        if f.size != self.npoints or f.size != w.size:
            raise ValueError(&#39;f and w should be the same size as mesh&#39;)

        f, w = self._shuffle_field(f, w)

        sigma = 0
        iflgs = 0
        prnt = -1

        f_smooth, df, ierr = _ssrfpack.smsurf(self._x, self._y, self._z, f, self.lst, self.lptr, self.lend,\
                                             iflgs, sigma, w, sm, smtol, gstol, prnt)

        import warnings

        # Note - warnings are good because they can be &#39;upgraded&#39; to exceptions by the
        # user of the module. The warning text is usually something that we don&#39;t
        # emit every time the error occurs. So here we emit a message about the problem
        # and a warning that explains it (once) - and also serves as a hook for an exception trap.

        if ierr &lt; 0:
            raise ValueError(&#39;ierr={} in smooth routines\n{}&#39;.format(ierr, _ier_codes[ierr]))

        if ierr == 1:
            warnings.warn(&#34;No errors were encountered but the constraint is not active --\n\
F, FX, and FY are the values and partials of a linear function which minimizes Q2(F), and Q1 = 0.&#34;)

        if ierr == 2:
            warnings.warn(&#34;The constraint could not be satisfied to within SMTOL due to ill-conditioned linear systems.&#34;)

        return self._deshuffle_field(f_smooth), self._deshuffle_field(df[0], df[1], df[2]), ierr</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.tri_area"><code class="name flex">
<span>def <span class="ident">tri_area</span></span>(<span>self, lons, lats)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculate the area enclosed by 3 points on the unit sphere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lons</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>3</code>)</dt>
<dd>longitudinal coordinates in radians</dd>
<dt><strong><code>lats</code></strong> :&ensp;<code>array</code> of <code>floats</code>, <code>shape</code> (<code>3</code>)</dt>
<dd>latitudinal coordinates in radians</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>float</code></dt>
<dd>area of triangle on the unit sphere</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tri_area(self, lons, lats):
    &#34;&#34;&#34;
    Calculate the area enclosed by 3 points on the unit sphere.

    Args:
        lons : array of floats, shape (3)
            longitudinal coordinates in radians
        lats : array of floats, shape (3)
            latitudinal coordinates in radians

    Returns:
        area : float
            area of triangle on the unit sphere

    &#34;&#34;&#34;
    lons, lats = self._check_integrity(lons, lats)

    # translate to unit sphere
    x, y, z = _stripack.trans(lats, lons)

    # compute area
    area = _stripack.areas(x, y, z)

    return area</code></pre>
</details>
</dd>
<dt id="stripy.spherical.sTriangulation.uniformly_refine_triangulation"><code class="name flex">
<span>def <span class="ident">uniformly_refine_triangulation</span></span>(<span>self, faces=False, trisect=False)</span>
</code></dt>
<dd>
<section class="desc"><p>return points defining a refined triangulation obtained by bisection of all edges
in the triangulation</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def uniformly_refine_triangulation(self, faces=False, trisect=False):
    &#34;&#34;&#34;
    return points defining a refined triangulation obtained by bisection of all edges
    in the triangulation
    &#34;&#34;&#34;

    if faces:
        lonv1, latv1 = self._add_face_centroids()

    else:
        if not trisect:
            lonv1, latv1 = self._add_spherical_midpoints()
        else:
            lonv1, latv1 = self._add_spherical_tripoints(ratio=0.333333)


    return lonv1, latv1</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="stripy" href="index.html">stripy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="stripy.spherical.angular_separation" href="#stripy.spherical.angular_separation">angular_separation</a></code></li>
<li><code><a title="stripy.spherical.dxyz2dlonlat" href="#stripy.spherical.dxyz2dlonlat">dxyz2dlonlat</a></code></li>
<li><code><a title="stripy.spherical.great_circle_Npoints" href="#stripy.spherical.great_circle_Npoints">great_circle_Npoints</a></code></li>
<li><code><a title="stripy.spherical.lonlat2xyz" href="#stripy.spherical.lonlat2xyz">lonlat2xyz</a></code></li>
<li><code><a title="stripy.spherical.remove_duplicate_lonlat" href="#stripy.spherical.remove_duplicate_lonlat">remove_duplicate_lonlat</a></code></li>
<li><code><a title="stripy.spherical.xyz2lonlat" href="#stripy.spherical.xyz2lonlat">xyz2lonlat</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="stripy.spherical.sTriangulation" href="#stripy.spherical.sTriangulation">sTriangulation</a></code></h4>
<ul class="">
<li><code><a title="stripy.spherical.sTriangulation.angular_separation" href="#stripy.spherical.sTriangulation.angular_separation">angular_separation</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.areas" href="#stripy.spherical.sTriangulation.areas">areas</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles" href="#stripy.spherical.sTriangulation.centroid_refine_triangulation_by_triangles">centroid_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.centroid_refine_triangulation_by_vertices">centroid_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.containing_simplex_and_bcc" href="#stripy.spherical.sTriangulation.containing_simplex_and_bcc">containing_simplex_and_bcc</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.containing_triangle" href="#stripy.spherical.sTriangulation.containing_triangle">containing_triangle</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_lengths" href="#stripy.spherical.sTriangulation.edge_lengths">edge_lengths</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles" href="#stripy.spherical.sTriangulation.edge_refine_triangulation_by_triangles">edge_refine_triangulation_by_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.edge_refine_triangulation_by_vertices">edge_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.face_midpoints" href="#stripy.spherical.sTriangulation.face_midpoints">face_midpoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.gradient_lonlat" href="#stripy.spherical.sTriangulation.gradient_lonlat">gradient_lonlat</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.gradient_xyz" href="#stripy.spherical.sTriangulation.gradient_xyz">gradient_xyz</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_segments" href="#stripy.spherical.sTriangulation.identify_segments">identify_segments</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_vertex_neighbours" href="#stripy.spherical.sTriangulation.identify_vertex_neighbours">identify_vertex_neighbours</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.identify_vertex_triangles" href="#stripy.spherical.sTriangulation.identify_vertex_triangles">identify_vertex_triangles</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate" href="#stripy.spherical.sTriangulation.interpolate">interpolate</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_cubic" href="#stripy.spherical.sTriangulation.interpolate_cubic">interpolate_cubic</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_linear" href="#stripy.spherical.sTriangulation.interpolate_linear">interpolate_linear</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.interpolate_nearest" href="#stripy.spherical.sTriangulation.interpolate_nearest">interpolate_nearest</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.join" href="#stripy.spherical.sTriangulation.join">join</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lats" href="#stripy.spherical.sTriangulation.lats">lats</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lons" href="#stripy.spherical.sTriangulation.lons">lons</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.lons_map_to_wrapped" href="#stripy.spherical.sTriangulation.lons_map_to_wrapped">lons_map_to_wrapped</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices" href="#stripy.spherical.sTriangulation.midpoint_refine_triangulation_by_vertices">midpoint_refine_triangulation_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.nearest_vertex" href="#stripy.spherical.sTriangulation.nearest_vertex">nearest_vertex</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.nearest_vertices" href="#stripy.spherical.sTriangulation.nearest_vertices">nearest_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.points" href="#stripy.spherical.sTriangulation.points">points</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_midpoints" href="#stripy.spherical.sTriangulation.segment_midpoints">segment_midpoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_midpoints_by_vertices" href="#stripy.spherical.sTriangulation.segment_midpoints_by_vertices">segment_midpoints_by_vertices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.segment_tripoints" href="#stripy.spherical.sTriangulation.segment_tripoints">segment_tripoints</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.simplices" href="#stripy.spherical.sTriangulation.simplices">simplices</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.smoothing" href="#stripy.spherical.sTriangulation.smoothing">smoothing</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.tri_area" href="#stripy.spherical.sTriangulation.tri_area">tri_area</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.uniformly_refine_triangulation" href="#stripy.spherical.sTriangulation.uniformly_refine_triangulation">uniformly_refine_triangulation</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.x" href="#stripy.spherical.sTriangulation.x">x</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.y" href="#stripy.spherical.sTriangulation.y">y</a></code></li>
<li><code><a title="stripy.spherical.sTriangulation.z" href="#stripy.spherical.sTriangulation.z">z</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>